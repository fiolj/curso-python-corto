.. _clase_01:

Clase 1: Conceptos b√°sicos de Python 
======================================


Caracter√≠sticas generales del lenguaje
--------------------------------------

Python presenta caracter√≠sticas modernas. Posiblemente su caracter√≠stica
m√°s visible/notable es que la estructuraci√≥n del c√≥digo est√° fuertemente
relacionada con su legibilidad:

-  Es un lenguaje interpretado (no se compila separadamente)

-  Provee tanto un entorno interactivo como de programas separados

-  Las funciones, bloques, √°mbitos est√°n definidos por la indentaci√≥n

-  Tiene una estructura altamente modular, permitiendo su reusabilidad

-  Es un lenguaje de *tipeado din√°mico*, no tenemos que declarar el tipo
   de variable antes de usarla.

Python es un lenguaje altamente modular con una biblioteca standard que
provee de funciones y tipos para un amplio rango de aplicaciones, y que
se distribuye junto con el lenguaje. Adem√°s hay un conjunto muy
importante de utilidades que pueden instalarse e incorporarse muy
f√°cilmente. El n√∫cleo del lenguaje es peque√±o, existiendo s√≥lo unas
pocas palabras reservadas:

====== ======== ======= ======== ======
False  class    finally is       return
====== ======== ======= ======== ======
None   continue for     lambda   try
True   def      from    nonlocal while
and    del      global  not      with
as     elif     if      or       yield
assert else     import  pass     
break  except   in      raise    
====== ======== ======= ======== ======

Adem√°s de las palabras reservadas, es relevante el caracter ``#``,
porque inicia un comentario que se contin√∫a hasta el final de la l√≠nea.
Los comentarios son fragmentos que se ignoran completamente en la
ejecuci√≥n del c√≥digo.

.. code:: python

    1+1
    # 3+3

Como vemos, la segunda l√≠nea es ignorada completamente.

Tipos simples de variables
--------------------------

Python es un lenguaje de muy alto nivel y por lo tanto trae muchos
*tipos* de datos ya definidos:

-  N√∫meros: enteros, reales, complejos
-  Tipos l√≥gicos (booleanos)
-  Cadenas de caracteres (strings) y bytes
-  Listas: una lista es una colecci√≥n de cosas, ordenadas, que pueden
   ser todas distintas entre s√≠
-  Diccionarios: Tambi√©n son colecciones de cosas, pero no est√°n
   ordenadas y son identificadas con una etiqueta
-  Conjuntos, tuples, ‚Ä¶

N√∫meros
~~~~~~~

Hay varios tipos de n√∫meros en Python. Aqu√≠ definimos y asignamos valor
a distintas variables:

.. code:: python

    a = 13
    b = 1.235
    c = a + b

.. code:: python

    print(a, type(a))


.. parsed-literal::

    13 <class 'int'>


.. code:: python

    print(b, type(b))
    print(c, type(c))


.. parsed-literal::

    1.235 <class 'float'>
    14.235 <class 'float'>


Esta es una de las caracter√≠sticas de Python. Se define el tipo de
variable en forma din√°mica, al asignarle un valor.

De la misma manera se cambia el tipo de una variable en forma din√°mica,
para poder operar. Por ejemplo en el √∫ltimo caso, la variable ``a`` es
de tipo ``int``, pero para poder sumarla con la variable ``b`` debe
convertirse su valor a otra de tipo ``float``.

.. code:: python

    print (a, type(a))
    a = 1.5 * a
    print (a, type(a))


.. parsed-literal::

    19.5 <class 'float'>
    29.25 <class 'float'>


Ahora, la variable ``a`` es del tipo ``float``.

.. note::  La funci√≥n ``print``
  
  Estuvimos usando, sin hacer ning√∫n comentario, la funci√≥n
  
  ::
  
     print(arg1, arg2, arg3, ..., sep=' ', end='\n', file=sys.stdout, flush=False)` 
  
  acepta un n√∫mero variable de argumentos. Imprime por pantalla todos los
  argumentos que se le pasan separados por el string ``sep`` (cuyo valor
  por defecto es un espacio), y termina con el string ``end`` (con valor
  por defecto *newline*).
  
  .. code:: python
  
      print?
  
  .. code:: python
  
      print(3,2,'hola')
      print(4,1,'chau')
  
  
  .. parsed-literal::
  
      3 2 hola
      4 1 chau
  
  
  .. code:: python
  
      print(3,2,'hola',sep='++++',end=' -> ')
      print(4,1,'chau',sep='++++')
  
  
  .. parsed-literal::
  
      3++++2++++hola -> 4++++1++++chau
  
  
  .. code:: python
  
      print(3,2,'hola',sep=',')
  
  
  .. parsed-literal::
  
      3,2,hola
  
  
  

N√∫meros complejos
^^^^^^^^^^^^^^^^^

Los n√∫meros complejos son parte standard del lenguaje, y las operaciones
b√°sicas que est√°n incorporadas en forma nativa pueden utilizarse
normalmente

.. code:: python

    z1 = 3 + 1j
    z2 = 2 + 2.124j
    print ('z1 =', z1, ', z2 =', z2)


.. parsed-literal::

    z1 = (3+1j) , z2 = (2+2.124j)


.. code:: python

    type(z1)




.. parsed-literal::

    complex



.. code:: python

    print('1.5j * z2 + z1 = ', 1.5j * z2 + z1)  # sumas, multiplicaciones de n√∫meros complejos
    print('z2¬≤ = ', z2**2)  # potencia de n√∫meros complejos
    print('conj(z1) = ',  z1.conjugate()  )


.. parsed-literal::

    1.5j * z2 + z1 =  (-0.18599999999999994+4j)
    z2¬≤ =  (-0.5113760000000003+8.496j)
    conj(z1) =  (3-1j)


.. code:: python

    print ('Im(z1) = ', z1.imag)
    print ('Re(z1) = ', z1.real)
    print ('abs(z1) = ', abs(z1))


.. parsed-literal::

    Im(z1) =  1.0
    Re(z1) =  3.0
    abs(z1) =  3.1622776601683795


Operaciones
^^^^^^^^^^^

Las operaciones aritm√©ticas b√°sicas son:

-  adici√≥n: ``+``
-  sustracci√≥n: ``-``
-  multiplicaci√≥n: ``*``
-  divisi√≥n: ``/``
-  potencia: ``**``
-  m√≥dulo: ``%``
-  divisi√≥n entera: ``//``

Las operaciones se pueden agrupar con parentesis y tienen precedencia
est√°ndar.

Divisi√≥n entera (//) significa quedarse con la parte entera de la
divisi√≥n (sin redondear).

.. note::  Las operaciones matem√°ticas est√°n incluidas en el lenguaje,
  pero las funciones no.
  
  En particular las funciones elementales: trigonom√©tricas, hiperb√≥licas,
  logaritmos no est√°n incluidas. En todos los casos es f√°cil utilizarlas
  porque las proveen m√≥dulos. Lo veremos pronto.
  
  

.. code:: python

    print('divisi√≥n de 20/3:         ', 20/3)
    print('parte entera de 20/3:     ', 20//3)
    print('fracci√≥n restante de 20/3:', 20/3 - 20//3)
    print('Resto de 20/3:            ', 20%3)


.. parsed-literal::

    divisi√≥n de 20/3:          6.666666666666667
    parte entera de 20/3:      6
    fracci√≥n restante de 20/3: 0.666666666666667
    Resto de 20/3:             2


En Python 3 la divisi√≥n entre n√∫meros enteros da como resultado un
n√∫mero flotante

.. code:: python

    print(20/5)
    print(type(20/5))
    print(20/3)


.. parsed-literal::

    4.0
    <class 'float'>
    6.666666666666667


.. warning::  En *Python 2.x* la divisi√≥n entre n√∫meros enteros es
  entera
  
  .. code:: python
  
      %%python2
      print 1/2,  20/3
  
  
  .. parsed-literal::
  
      0 6
  
  
  .. code:: python
  
      print( 1//2,  20//3)  # Divisi√≥n entera 
      print( 1/2,  20/3)    # Divisi√≥n
  
  
  .. parsed-literal::
  
      0 6
      0.5 6.666666666666667
  
  
  

Tipos simples: Booleanos
~~~~~~~~~~~~~~~~~~~~~~~~

Los tipos l√≥gicos o *booleanos*, pueden tomar los valores *Verdadero* o
*Falso* (``True`` o ``False``). Tambi√©n hay un tipo *especial*, el
elemento ``None``.

.. code:: python

    t = False
    print('¬øt is True?', t == True)
    print('¬øt is False?', t == False)


.. parsed-literal::

    ¬øt is True? False
    ¬øt is False? True


Los valores se pueden asignar a variables, como se hace con n√∫meros

.. code:: python

    c = (t == True)
    print('¬øt is True?', c)
    print (type(c))


.. parsed-literal::

    ¬øt is True? False
    <class 'bool'>


El tipo ``None`` no es un n√∫mero, pero tampoco es Verdadero o Falso

.. code:: python

    print ('True == None: ',True == None)
    print ('False == None: ', False == None)


.. parsed-literal::

    True == None:  False
    False == None:  False


.. code:: python

    a = None
    print ('type(a): ',type(a))
    print (bool(None))


.. parsed-literal::

    type(a):  <class 'NoneType'>
    False


Aqu√≠ hemos estado preguntando si dos cosas eran iguales o no (igualdad).
Tambi√©n podemos preguntar si una **es** la otra (identidad). En el
siguiente ejemplo vemos que dos variables pueden tener el mismo valor
pero ser diferentes

.. code:: python

    d = 1.5
    a = d
    print(d == a)
    print(d is a)


.. parsed-literal::

    True
    True


.. code:: python

    d = 1.5
    a = 1.5
    print(d == a)
    print(d is a)


.. parsed-literal::

    True
    False


Sin embargo, dos variables que tienen valores ``True`` son efectivamente
‚Äúla misma‚Äù (son id√©nticas). Lo mismo ocurre con ``False`` y ``None``

.. code:: python

    a = True
    b = True
    c = None
    d = None
    print ('a is True: ', a is True)
    print ('c is None: ', c is None)
    print("¬øSon id√©nticas las variables?")
    print ('b is a: ', b is a)
    print ('d is c: ', d is c)


.. parsed-literal::

    a is True:  True
    c is None:  True
    ¬øSon id√©nticas las variables?
    b is a:  True
    d is c:  True


Operadores l√≥gicos
^^^^^^^^^^^^^^^^^^

Los operadores l√≥gicos en Python son muy explicitos:

::

   A == B  (A igual que B)
   A > B   (A mayor que B)
   A < B   (A menor que B)
   A >= B  (A igual o mayor que B)
   A <= B  (A igual o menor que B)
   A != B  (A diferente que B)
   A in B  (A incluido en B)
   A is B  (Identidad: A es el mismo elemento que B)

y a todos los podemos combinar con ``not``, que niega la condici√≥n

.. code:: python

    print ('¬ø20/3 == 6?  ->', 20/3 == 6)
    print ('¬ø20//3 == 6? ->', 20//3 == 6)
    print ('¬ø20//3 >= 6? ->', 20//3 >= 6)
    print ('¬ø20//3 > 6?  ->', 20//3 > 6)


.. parsed-literal::

    ¬ø20/3 == 6?  -> False
    ¬ø20//3 == 6? -> True
    ¬ø20//3 >= 6? -> True
    ¬ø20//3 > 6?  -> False


.. code:: python

    a = 1001
    b = 1001
    print ('a == b     ->', a == b)
    print ('a is b     ->', a is b)
    print ('a is not b ->', a is not b)


.. parsed-literal::

    a == b     -> True
    a is b     -> False
    a is not b -> True


Note que en las √∫ltimas dos l√≠neas estamos fij√°ndonos si las dos
variables son la misma (identidad), y no ocurre aunque sus valores son
iguales.

Modularizaci√≥n y reuso
----------------------

Los m√≥dulos son el mecanismo de Python para reusar c√≥digo. Una gran
ventaja del lenguaje es que ya existen muchos m√≥dulos que son parte de
la biblioteca *standard*. Adem√°s, existen numerosas bibliotecas y
m√≥dulos para ayudarnos en cualquier tarea.

El uso de los m√≥dulos es muy simple, para poder aprovecharlo
necesitaremos saber dos cosas:

-  Qu√© funciones est√°n ya definidas y listas para usar
-  C√≥mo acceder a ellas

La primera pregunta: c√≥mo saber cu√°les son los posibles m√≥dulos que ya
est√°n definidos, su nombre, y que funciones est√°n disponibles tiene una
respuesta muy general que es ‚Äúbuscar‚Äù (en internet). La primera
respuesta que podemos (deber√≠amos) intentar es: la
`documentaci√≥n <https://docs.python.org/es/3/index.html>`__, y en
particular la `biblioteca
standard <https://docs.python.org/es/3/library/index.html>`__.

La segunda cuesti√≥n: una vez que sabemos qu√© existe (y no necesitamos
reinventar), c√≥mo podemos usarlo:

Para utilizar todas las funcionalidades que est√°n definidas en un
*modulo* debemos primero hacerle saber a nuestro programa que existen.
Eso se hace *importando* el m√≥dulo con el simple comando
``import modulo``, donde modulo es el nombre que queremos importar.

Una vez importado, podemos utilizar constantes y funciones definidas en
el m√≥dulo con la notaci√≥n ‚Äúde punto‚Äù: ``modulo.funcion()``.

Ejemplos: M√≥dulos math y cmath
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

El m√≥dulo `math <https://docs.python.org/es/3/library/math.html>`__
contiene funciones y utilidades para trabajar con n√∫meros reales
(enteros y punto flotante). Es parte de la biblioteca standard de Python
por lo que no tenemos que instalar nada nuevo. Contiene todas las
funciones m√°s comunes (trigonom√©tricas, exponenciales, logaritmos, etc)
y algunas constantes importantes (:math:`\pi`, e, etc). En realidad es
una interface para dar acceso a la biblioteca ``math`` en C.

Veamos como utilizarlo:

.. code:: python

    import math

Despu√©s de este comando, tenemos disponible todos los objetos definidos
(por alg√∫n amable programador) en el m√≥dulo
`math <https://docs.python.org/es/3/library/math.html>`__

.. code:: python

    # Veamos el valor de Pi:
    math.pi




.. parsed-literal::

    3.141592653589793



.. code:: python

    # algunas constantes y funciones elementales
    raiz5pi = math.sqrt(5*math.pi)

.. code:: python

    raiz5pi




.. parsed-literal::

    3.963327297606011



Otras funciones disponibles son ``floor`` y ``ceil``:

.. code:: python

    print (raiz5pi, math.floor(raiz5pi), math.ceil(raiz5pi))
    print (math.e, math.floor(math.e), math.ceil(math.e))


.. parsed-literal::

    3.963327297606011 3 4
    2.718281828459045 2 3


Como puede leerse en la documentaci√≥n del m√≥dulo, se definen tambi√©n
funciones elementales:

.. code:: python

    # algunas funciones elementales
    print (math.log(1024,2), math.log(27,3))
    print (math.factorial(7), math.factorial(9), math.factorial(10))
    print ('Combinatorio: C(6,2):',math.factorial(6)/(math.factorial(4)*math.factorial(2)))


.. parsed-literal::

    10.0 3.0
    5040 362880 3628800
    Combinatorio: C(6,2): 15.0


A veces, s√≥lo necesitamos unas pocas funciones de un m√≥dulo. Entonces
para abreviar la notaci√≥n combiene importar s√≥lo lo que vamos a usar,
usando la notaci√≥n:

``from xxx import yyy``

.. code:: python

    from math import sqrt, pi, log, floor

.. code:: python

    raiz5pi = sqrt(5*pi)
    print (log(1024, 2))
    print (raiz5pi, floor(raiz5pi))


.. parsed-literal::

    10.0
    3.963327297606011 3


.. note::  Para importar todas las definiciones de un m√≥dulo pueden
  encontrar la (perfectamente v√°lida) notaci√≥n:
  
  ``from xxx import *``
  
  donde el asterisco indica ‚Äútodo‚Äù. Este uso no est√° recomendado porque
  varios m√≥dulos pueden usar los mismos nombres y no sabr√≠amos cu√°l
  estamos usando. Tambi√©n puede traer inconvenientes si despu√©s queremos
  reusar el c√≥digo que estamos escribiendo.
  
  

Otra opci√≥n es utilizar un ‚Äúalias‚Äù para el m√≥dulo. Esto permite mantener
informaci√≥n del origen de los objetos sin tener que escribir el nombre
completo

.. code:: python

    import math as m
    m.sqrt(3.2)




.. parsed-literal::

    1.7888543819998317



El m√≥dulo ``math`` contiene funciones para trabajar con n√∫meros reales

.. code:: python

    import math
    try:
        math.sqrt(-1)


::


      File "<ipython-input-45-dcf65d789be2>", line 3
        math.sqrt(-1)
                     ^
    SyntaxError: unexpected EOF while parsing



y falla con n√∫meros complejos, para ello existe el m√≥dulo
`cmath <https://docs.python.org/es/3/library/cmath.html>`__

.. code:: python

    import cmath as c

Ahora tenemos a nuestra disposici√≥n todas las utilidades definidas en el
m√≥dulo:

.. code:: python

    print('Usando cmath (-1)^0.5: ', c.sqrt(-1))


.. parsed-literal::

    Usando cmath (-1)^0.5:  1j


.. code:: python

    print(c.cos(c.pi/3 + 2j))


.. parsed-literal::

    (1.8810978455418161-3.1409532491755083j)


Si queremos calcular la fase (el √°ngulo que forma con el eje x) podemos
usar la funci√≥n phase

.. code:: python

    z = 1 + 1j
    c.phase(z)                  # Resultado en radianes




.. parsed-literal::

    0.7853981633974483



.. code:: python

    math.degrees(c.phase(z))    # Resultado en grados




.. parsed-literal::

    45.0



Disgresi√≥n: Objetos
-------------------

En python, cualquier elemento es un *objeto*. Todos los objetos tienen,
al menos:

-  un tipo,
-  un valor,
-  una identidad.

Adem√°s, pueden tener *m√©todos*, es decir funciones asociadas que,
habitualmente, act√∫an sobre el objeto que la posee. Veamos algunos
ejemplos cotidianos:

.. code:: python

    z = 1 + 1j
    print(z, type(z))
    print( z.real )
    print( z.imag )
    print( z.conjugate )
    print( z.conjugate() )


.. parsed-literal::

    (1+1j) <class 'complex'>
    1.0
    1.0
    <built-in method conjugate of complex object at 0x7f2873f0bd50>
    (1-1j)


Los n√∫meros complejos tienen un valor (en este caso :math:`1 + i`), pero
adem√°s tienen m√°s informaci√≥n (su parte real, imaginaria) y una funci√≥n
que nos da su conjugado.

Los n√∫meros enteros, m√°s simples, tambi√©n son objetos, con propiedades y
m√©todos:

.. code:: python

    a = 3                           # N√∫meros enteros
    print(type(a))
    a.bit_length()


.. parsed-literal::

    <class 'int'>




.. parsed-literal::

    2



.. code:: python

    a = 12312
    print(type(a))
    a.bit_length()


.. parsed-literal::

    <class 'int'>




.. parsed-literal::

    14



En estos casos, usamos el m√©todo ``bit_length`` de los enteros, que nos
dice cu√°ntos bits son necesarios para representar el n√∫mero.

Ejercicios
----------

1. Para el n√∫mero complejo :math:`z= 1 + 0.5 i`

   -  Calcular :math:`z^2, z^3, z^4, z^5.`
   -  Calcular los complejos conjugados de :math:`z`, :math:`z^2` y
      :math:`z^3`.
   -  Escribir :math:`z`, :math:`z^2` y :math:`z^3` en coordenadas
      polares.

   (Recuerde que puede utilizar los m√≥dulos ``math`` y/o ``cmath``)

Tipos compuestos
----------------

En Python, adem√°s de los tipos simples (n√∫meros y booleanos, entre
ellos) existen tipos compuestos, que pueden contener m√°s de un valor de
alg√∫n tipo. Entre los tipos compuestos m√°s importantes vamos a
referirnos a:

-  | `Strings <https://docs.python.org/es/3/library/stdtypes.html#text-sequence-type-str>`__
   | Se pueden definir con comillas dobles ( " ), comillas simples ( ‚Äô
     ), o tres comillas (simples o dobles). Comillas (dobles) y comillas
     simples producen el mismo resultado. S√≥lo debe asegurarse que se
     utiliza el mismo tipo para abrir y para cerrar el *string*
   | Ejemplo: ``s = "abc"`` (el elemento ``s[0]`` tiene el valor
     ``"a"``).

-  | `Listas <https://docs.python.org/es/3/library/stdtypes.html#sequence-types-list-tuple-range>`__
   | Las listas son tipos que pueden contener m√°s de un elemento de
     cualquier tipo. Los tipos de los elementos pueden ser diferentes.
     Las listas se definen separando los diferentes valores con comas,
     encerrados entre corchetes. Se puede referir a un elemento por su
     √≠ndice.
   | Ejemplo: ``L = ["a",1, 0.5 + 1j]`` (el elemento ``L[0]`` es igual
     al *string* ``"a"``).

-  | `Tuplas <https://docs.python.org/es/3/library/stdtypes.html#sequence-types-list-tuple-range>`__
   | Las tuplas se definen de la misma manera que las listas pero con
     par√©ntesis en lugar de corchetes. Ejemplo:
     ``T = ("a",1, 0.5 + 1j).``

-  | `Diccionarios <https://docs.python.org/es/3/library/stdtypes.html#mapping-types-dict>`__
   | Los diccionarios son contenedores a cuyos elementos se los
     identifica con un nombre (*key*) en lugar de un √≠ndice. Se los
     puede definir dando los pares ``key:value`` entre llaves
   | Ejemplo: ``D = {'a': 1, 'b': 2, 1: 'hola', 2: 3.14}`` (el elemento
     ``D['a']`` es igual al n√∫mero 1).

-  | `Numpy
     Arrays <https://numpy.org/doc/stable/user/absolute_beginners.html#what-is-an-array>`__
   | Los *arrays* de
     `Numpy <https://numpy.org/doc/stable/user/whatisnumpy.html>`__ son
     vectores (multidimensionales) que est√°n optimizados para c√°lculos.
     Sus elementos deben ser todos del mismo tipoy pueden accederse por
     √≠ndice en una misma similar que a los *strings*, *listas* y
     *tuples*
   | Ejemplo: ``A = numpy.array([1., 2., 3.])`` (el elemento ``A[0]`` es
     igual al n√∫mero 1).

Strings: Secuencias de caracteres
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Una cadena o *string* es una **secuencia** de caracteres (letras,
‚Äún√∫meros‚Äù, s√≠mbolos).

Se pueden definir con comillas, comillas simples, o tres comillas
(simples o dobles). Comillas (normales) y comillas simples producen el
mismo resultado. S√≥lo debe asegurarse que se utiliza el mismo tipo para
abrir y para cerrar el *string*

.. code:: python

    saludo = 'Hola Mundo'
    otro= "that's all"
    dijo = '√âl dijo: "hola" y yo no dije nada'

.. code:: python

    print(saludo)


.. parsed-literal::

    Hola Mundo


.. code:: python

    print(otro)


.. parsed-literal::

    that's all


.. code:: python

    print(dijo)


.. parsed-literal::

    √âl dijo: "hola" y yo no dije nada


.. note::  Python trabaja con una codificaci√≥n (*UTF-8*) por lo que
  reconoce nativamente un amplio rango de caracteres
  
  .. code:: python
  
      label = "œÉ = Œª T/ ¬µ + œÄ ¬∑ Œ¥Œæ"
      print('tipo de label: ', type(label))
      print ('Resultados corresponden a:', label, ' (en m¬≤)')
  
  
  .. parsed-literal::
  
      tipo de label:  <class 'str'>
      Resultados corresponden a: œÉ = Œª T/ ¬µ + œÄ ¬∑ Œ¥Œæ  (en m¬≤)
  
  
  

Tres comillas (simples o dobles) sirven para incluir una cadena de
caracteres en forma textual, incluyendo saltos de l√≠neas.

.. code:: python

    Texto_largo = '''Aqu√≠ me pongo a cantar
    Al comp√°s de la vig√ºela,
    Que el hombre que lo desvela
    Una pena estraordinaria
    Como la ave solitaria
    Con el cantar se consuela.'''

.. code:: python

    print(Texto_largo)


.. parsed-literal::

    Aqu√≠ me pongo a cantar
    Al comp√°s de la vig√ºela,
    Que el hombre que lo desvela
    Una pena estraordinaria
    Como la ave solitaria
    Con el cantar se consuela.


Operaciones
^^^^^^^^^^^

En **Python** ya hay definidas algunas operaciones como suma
(composici√≥n o concatenaci√≥n), producto por enteros (repetici√≥n).

Suma de *strings*
'''''''''''''''''

La suma entre dos cadenas de caracteres est√° definida y el resultado es
una nueva cadena, conteniendo la concatenaci√≥n de los dos sumandos

.. code:: python

    s = saludo + " ----> [" + dijo + "] <---- chau"
    print(s)


.. parsed-literal::

    Hola Mundo ----> [√âl dijo: "hola" y yo no dije nada] <---- chau


Multiplicaci√≥n por un entero
''''''''''''''''''''''''''''

La multiplicaci√≥n de un n√∫mero entero ``n`` por un string ``s`` est√°
definida como ‚Äún veces s‚Äù

.. code:: python

    print( saludo )
    print( 2*saludo )
    print( 10*"+" + 2* ( saludo + "," ) + 10*"+" + 2*"\n" + "Chau" )


.. parsed-literal::

    Hola Mundo
    Hola MundoHola Mundo
    ++++++++++Hola Mundo,Hola Mundo,++++++++++
    
    Chau


Notar que (obviamente) hay una diferencia entre un n√∫mero y un string
cuyo valor podemos interpretar como el n√∫mero. Ac√°, la variable ``a`` es
un *string* y ``b`` en un n√∫mero entero

.. code:: python

    a = '1'
    b = 1
    print(a, type(a))
    print(b, type(b))


.. parsed-literal::

    1 <class 'str'>
    1 <class 'int'>


En consecuencia, las operaciones tienen distinto significado:

.. code:: python

    print ( a + a )
    print ( 3*a )
    print ( a*3 )


.. parsed-literal::

    11
    111
    111


.. code:: python

    print ( b + b )
    print ( 3*b )
    print ( b*3 )


.. parsed-literal::

    2
    3
    3


Tambi√©n podemos calcular la longitud de un *string* con la funci√≥n
``len()``

.. code:: python

    len(saludo)




.. parsed-literal::

    10



Utilizando esta funci√≥n podemos hacer un centrado de texto ‚Äúmanual‚Äù

.. code:: python

    n = int((30-len(saludo)//2)) 
    print (n*'*', saludo, n*'*')


.. parsed-literal::

    ************************* Hola Mundo *************************


.. code:: python

    ntext = "Nuevo texto que queremos centrar"
    n = int((30-len(ntext)//2)) 
    print (n*'<', ntext,n*'>')


.. parsed-literal::

    <<<<<<<<<<<<<< Nuevo texto que queremos centrar >>>>>>>>>>>>>>


Indexado de *strings*
^^^^^^^^^^^^^^^^^^^^^

Los *strings* poseen varias cualidades y funcionalidades. Por ejemplo:

-  Se puede iterar sobre ellos, o quedarse con una parte (slicing)
-  Tienen m√©todos (funciones que se aplican a su *due√±o*)

Podemos referirnos a un caracter o una parte de una cadena de caracteres
mediante su √≠ndice. Los √≠ndices en **Python** empiezan en 0.

.. code:: python

    s = "0123456789"
    print ('Primer caracter  :', s[0])
    print ("Segundo caracter :", s[1])
    print ("El √∫ltimo caracter :", s[-1])
    print ("El ante√∫ltimo caracter :", s[-2])


.. parsed-literal::

    Primer caracter  : 0
    Segundo caracter : 1
    El √∫ltimo caracter : 9
    El ante√∫ltimo caracter : 8


Tambi√©n podemos elegir un subconjunto de caracteres:

.. code:: python

    print ('Los tres primeros:          ', s[:3])
    print ('Todos a partir del tercero: ', s[3:])
    print ('Los √∫ltimos dos:            ', s[-2:])
    print ('Todos menos los √∫ltimos dos:', s[:-2])


.. parsed-literal::

    Los tres primeros:           012
    Todos a partir del tercero:  3456789
    Los √∫ltimos dos:             89
    Todos menos los √∫ltimos dos: 01234567


Estas ‚Äúsubcadenas‚Äù son cadenas de caracteres, y por lo tanto pueden
utilizarse de la misma manera que cualquier otra cadena:

.. code:: python

    print (s[:3] + s[-2:])


.. parsed-literal::

    01289


La selecci√≥n de elementos y subcadenas de una cadena ``s`` tiene la
forma ``s[i:f:p]`` donde ``i, f, p`` son enteros. La notaci√≥n se refiere
a la subcadena empezando en el √≠ndice ``i``, hasta el √≠ndice ``f``
recorriendo con paso ``p``. Casos particulares de esta notaci√≥n son:

-  Un √≠ndice simple. Por ejemplo ``s[3]`` se refiere al tercer elemento
-  Un √≠ndice negativo se cuenta desde el final, empezando desde ``-1``
-  Si el paso ``p`` no est√° presente el valor por defecto es 1. Ejemplo:
   ``s[2:4] = s[2:4:1]``
-  Si se omite el primer √≠ndice, el valor asumido es 0. Ejemplo:
   ``s[:2:1] = s[0:2:1]``
-  Si se omite el segundo √≠ndice, el valor asumido es -1. Ejemplo:
   ``s[1::1] = s[1:-1:1]``
-  Notar que puede omitirse m√°s de un √≠ndice. Ejemplo:
   ``s[::2] = s[0:-1:2]``

.. code:: python

    print (s[2:4])
    print (s[:2:1])
    print (s[::-1])
    s1 = s[:1:-3]


.. parsed-literal::

    23
    01
    9876543210


.. code:: python

    s1




.. parsed-literal::

    '963'



Formato de *strings*
^^^^^^^^^^^^^^^^^^^^

Existen varias maneras de aplicar formato a una cadena de caracteres.
Vamos a ver dos opciones: - Uso del m√©todo ``format`` - Uso de
‚Äúf-strings‚Äù

.. code:: python

    from math import pi
    s1 = "El valor de œÄ es {}"

.. code:: python

    s1




.. parsed-literal::

    'El valor de œÄ es {}'



.. code:: python

    s1 = "El valor de œÄ es {}".format(pi)

.. code:: python

    s1




.. parsed-literal::

    'El valor de œÄ es 3.141592653589793'



.. code:: python

    h = 7    # Hora
    T = 5.2  # Temperatura en grados
    s2 = "La temperatura a las {} horas era {} grados".format(h, T)

.. code:: python

    print(s2)


.. parsed-literal::

    La temperatura a las 7 horas era 5.2 grados


Aqu√≠ definimos un *string* llamado ``s1``, donde utilizamos el valor de
la variable pi (definida en el m√≥dulo math) para completar el valor.

.. code:: python

    print(s1)


.. parsed-literal::

    El valor de œÄ es 3.141592653589793


En su versi√≥n m√°s simple la funci√≥n ``format`` reemplaza el lugar entre
llaves por el valor dado, en este caso un n√∫mero. Esta funci√≥n permite
m√°s de un argumento, y reemplaza operaciones por su resultado, como en
el siguiente ejemplo:

.. code:: python

    s2 = "El valor de œÄ es {} y su doble es {}".format(pi, 2*pi)
    print(s2)


.. parsed-literal::

    El valor de œÄ es 3.141592653589793 y su doble es 6.283185307179586


El mismo efecto se puede obtener utilizando interpolaci√≥n literal
(‚Äúf-strings‚Äù)

.. code:: python

    s1 = f"El valor de œÄ es {pi}"
    s2 = f"El valor de œÄ es {pi} y su doble es {2*pi}"

.. code:: python

    print(s1)
    print(s2)


.. parsed-literal::

    El valor de œÄ es 3.141592653589793
    El valor de œÄ es 3.141592653589793 y su doble es 6.283185307179586


Notar que no es necesario definir una variable previamente para imprimir
un string. Los ejemplos anteriores pueden escribirse:

.. code:: python

    print( f"El valor de œÄ es {pi} y su doble es {2*pi}" )
    print( "El valor de œÄ es {} y su doble es {}".format(pi, 2*pi) )

Para controlar el formato de los strings existe una notaci√≥n espec√≠fica
que se puede indicar dentro de las llaves tanto para el `m√©todo
format <https://docs.python.org/es/3/library/string.html#formatstrings>`__
como para los
`‚Äúf-strings‚Äù <https://docs.python.org/es/3/reference/lexical_analysis.html#f-strings>`__.
En su versi√≥n m√°s simple se agregan ‚Äú:‚Äù (dos puntos) seguidos del
formato deseado. Por ejemplo para imprimir con s√≥lo cuatro decimales
podemos escribir:

.. code:: python

    print("El valor de œÄ con cuatro decimales es {:.4f}".format(pi))
    print(f"El valor de œÄ con cuatro decimales es {pi:.4f}")


.. parsed-literal::

    El valor de œÄ con cuatro decimales es 3.1416
    El valor de œÄ con cuatro decimales es 3.1416


M√©todos de Strings
^^^^^^^^^^^^^^^^^^

M√©todos son ‚Äúfunciones‚Äù que act√∫an sobre el mismo objeto y son parte de
su definici√≥n.

Por ejemplo, cuando uno define un *string*, ya est√° en la definici√≥n
incluida la informaci√≥n sobre como realizar algunas operaciones.

Veamos algunos de los m√©todos definidos sobre *strings*:

.. code:: python

    a = "La mar estaba serena!"
    print(a)


.. parsed-literal::

    La mar estaba serena!


En python existe un m√©todo ``replace()`` que hace que sea muy f√°cil
reemplazar una subcadena por otra:

.. code:: python

    b = a.replace('e','a')
    print(b)


.. parsed-literal::

    La mar astaba sarana!


Separar las palabras:

.. code:: python

    b.split()




.. parsed-literal::

    ['La', 'mar', 'astaba', 'sarana!']



.. code:: python

    b.split('a')




.. parsed-literal::

    ['L', ' m', 'r ', 'st', 'b', ' s', 'r', 'n', '!']



Estos son m√©todos que tienen definidos **todos** los *strings*.

Un m√©todo es una funci√≥n que est√° definida junto con el objeto. En este
caso el string. Hay m√°s informaci√≥n sobre los m√©todos de las cadenas de
caracteres en: `String
Methods <https://docs.python.org/3/library/stdtypes.html#string-methods>`__

Veamos algunos ejemplos m√°s:

.. code:: python

    # Definimos dos strings
    a = 'Hola Mundo!'
    b = "Somos los colectiveros que cumplimos nuestro deber!"

Buscar y reemplazar cosas en un string:

.. code:: python

    # find nos da el √≠ndice del lugar en el string donde se encuentra el substring dado
    b.find('le')




.. parsed-literal::

    12



.. code:: python

    print (b)
    print (b.replace('que','y')) # Reemplazamos un substring


.. parsed-literal::

    Somos los colectiveros que cumplimos nuestro deber!
    Somos los colectiveros y cumplimos nuestro deber!


.. code:: python

    b.center(70,' ')




.. parsed-literal::

    '         Somos los colectiveros que cumplimos nuestro deber!          '



Para encontrar informaci√≥n sobre un ``comando`` en las *notebooks*
podemos usar la notaci√≥n ``comando?``. Por ejemplo, si queremos saber
como funciona el m√©todo ``find`` de los strings, usamos (recordar que
definimos antes ``b`` como un *string*):

.. code:: python

    b.find?



.. parsed-literal::

    [0;31mDocstring:[0m
    S.find(sub[, start[, end]]) -> int
    
    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.
    
    Return -1 on failure.
    [0;31mType:[0m      builtin_function_or_method



Ejercicios
~~~~~~~~~~

1. Escribir un programa, utilizando formateo de strings, que escriba las
   frases:

   -  ‚ÄúEl conjugado de z=1+0.5j es 1-0.5j‚Äù
   -  ‚ÄúEl conjugado de z=(1+0.5j)^2 es ‚Ä¶‚Äù (con el valor correspondiente)
   -  ‚ÄúEl conjugado de z=(1+0.5j) :math:`\pi` es ‚Ä¶‚Äù (con el valor
      correspondiente s√≥lo hasta el tercer decimal incluido)

.. code:: python

    from math import pi
    
    z = (1 + 0.5j)
    zpic = (z * pi).conjugate()
    print( f"El conjugado de z = {z}œÄ es {zpic:.3f}" )


.. parsed-literal::

    El conjugado de z = (1+0.5j)œÄ es 3.142-1.571j


Conversi√≥n de tipos
~~~~~~~~~~~~~~~~~~~

Como comentamos anteriormente, y se ve en los ejemplos anteriores, uno
no define el tipo de variable *a-priori* sino que queda definido al
asign√°rsele un valor (por ejemplo ``a=3`` define a como una variable del
tipo entero).

Si bien **Python** hace la conversi√≥n de tipos de variables en algunos
casos, **no hace magia**, no puede adivinar nuestra intenci√≥n si no la
explicitamos.

.. code:: python

    a = 3                           # a es entero
    b = 3.1                         # b es real
    c = 3 + 0j                      # c es complejo
    print (f"a es de tipo {type(a)}\nb es de tipo {type(b)}\nc es de tipo {type(c)}")
    print (f"'a + b' es de tipo {type(a+b)} y 'a + c' es de tipo {type(a+c)}")

.. code:: python

    try:
        print (1+'1')

Sin embargo, si le decimos expl√≠citamente qu√© conversi√≥n queremos, todo
funciona bien

.. code:: python

    print (str(1) + '1')
    print (1 + int('1'))
    print (1 + float('1.e5'))
    print ("x=" + str(1.e5))
    print ('x=' + str(1.e-5))

.. code:: python

    # a menos que nosotros **nos equivoquemos expl√≠citamente**
    try:
        print (1 + int('z'))

Listas
~~~~~~

Las listas son tipos compuestos, donde todos sus elementos pueden ser
del mismo tipo o no. Algunas caracter√≠sticas de las listas son:

-  Los elementos no son necesariamente homog√©neos en tipo

-  Elementos ordenados

-  Acceso mediante un √≠ndice

-  El valor de sus elementos pueden modificarse (esto no es cierto para
   *strings* ni *tuplas*)

-  Est√°n definidas operaciones entre Listas, as√≠ como algunos m√©todos

   -  ``x in L`` (¬øx es un elemento de L?)
   -  ``x not in L`` (¬øx no es un elemento de L?)
   -  ``L1 + L2`` (concatenar L1 y L2)
   -  ``n*L1`` (n veces L1)
   -  ``L1*n`` (n veces L1)
   -  ``L[i]`` (Elemento i-√©simo)
   -  ``L[i:j]`` (Elementos i a j)
   -  ``L[i:j:k]`` (Elementos i a j, elegidos uno de cada k)
   -  ``len(L)`` (longitud de L)
   -  ``min(L)`` (M√≠nimo de L)
   -  ``max(L)`` (M√°ximo de L)
   -  ``L.index(x, [i])`` (√çndice de x, iniciando en i)
   -  ``L.count(x)`` (N√∫mero de veces que aparece x en L)
   -  ``L.append(x)`` (Agrega el elemento x al final)

Veamos algunos ejemplos:

.. code:: python

    cuadrados = [1, 9, 16, 25]

En esta l√≠nea hemos declarado una variable llamada ``cuadrados``, y le
hemos asignado una lista de cuatro elementos. En algunos aspectos las
listas son muy similares a los *strings*. Se pueden realizar muchas de
las mismas operaciones en strings, listas y otros objetos sobre los que
se pueden iterar (*iterables*).

Las listas pueden accederse por posici√≥n y tambi√©n pueden rebanarse
(*slicing*)

Los √≠ndices pueden ser positivos (empezando desde cero) o negativos
empezando desde -1.

================== == == == ==
cuadrados:         1  9  16 25
================== == == == ==
√≠ndices:           0  1  2  3
√≠ndices negativos: -4 -3 -2 -1
================== == == == ==

Operaciones sobre listas
^^^^^^^^^^^^^^^^^^^^^^^^

Veamos algunas operaciones que se pueden realizar sobre listas. Por
ejemplo, se puede f√°cilmente:

-  concatenar dos listas,
-  buscar un valor dado,
-  agregar elementos,
-  borrar elementos,
-  calcular su longitud,
-  invertirla

Empecemos concatenando dos listas, usando el operador ‚Äúsuma‚Äù

.. code:: python

    L = [0,1,2,3,4,5]

.. code:: python

    L1 = L+L

.. code:: python

    L1




.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5]



La multiplicaci√≥n por un entero act√∫a igual que en el caso de *strings*

.. code:: python

    2*L == L + L                     # Igualdad de cada uno de los elementos




.. parsed-literal::

    True



.. code:: python

    L1.index(3)                      # √çndice del elemento de valor 3




.. parsed-literal::

    3



.. code:: python

    L1.count(3)                      # Cuenta las veces que aparece el valor "3"




.. parsed-literal::

    2



Las listas tienen definidos m√©todos, que podemos ver con la ayuda
incluida, por ejemplo haciendo ``help(list)``

Si queremos agregar un elemento al final utilizamos el m√©todo
``append``:

.. code:: python

    print(L)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5]


.. code:: python

    L.append(8)

.. code:: python

    print(L)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 8]


Notar que, como las listas pueden contener cualquier cosa (incluso otras
listas), tratar de agregar una lista al final de otra con el m√©todo
``append`` puede dar resultados inesperados

.. code:: python

    L.append([9, 8, 7])
    print(L)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 8, [9, 8, 7]]


.. code:: python

    L.pop(-1)  # pop() devuelve el elemento correspondiente y lo saca de la lista 




.. parsed-literal::

    [9, 8, 7]



.. code:: python

    L




.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 8]



Si queremos agregar m√°s de un elemento a una lista podemos usar
``extend``

.. code:: python

    L.extend([9,8,7])
    print(L)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 8, 9, 8, 7]


o sumar la nueva lista y asignarla a la misma variable

.. code:: python

    L += [3,2,1]         # equivalente a L = L + [3,2,1]
    print(L)


.. parsed-literal::

    [0, 1, 2, 3, 4, 5, 8, 9, 8, 7, 3, 2, 1]


Si queremos insertar un elemento en una posici√≥n que no es el final de
la lista, usamos el m√©todo ``insert()``. Por ejemplo para insertar el
valor 6 en la primera posici√≥n:

.. code:: python

    L.insert(3,99)
    print(L)


.. parsed-literal::

    [0, 1, 2, 99, 3, 4, 5, 8, 9, 8, 7, 3, 2, 1]


En las listas podemos sobreescribir uno o m√°s elementos

.. code:: python

    print(L)
    L[0:3] = [-2,-3,-4]
    print(L)


.. parsed-literal::

    [0, 1, 2, 99, 3, 4, 5, 8, 9, 8, 7, 3, 2, 1]
    [-2, -3, -4, 99, 3, 4, 5, 8, 9, 8, 7, 3, 2, 1]


.. code:: python

    L[0] = -9
    L[-2:]=[0,1]
    print(L)


.. parsed-literal::

    [-9, -3, -4, 99, 3, 4, 5, 8, 9, 8, 7, 3, 0, 1]


.. code:: python

    print(L)
    L.remove(3)                     # Remueve la primera ocurrencia de 3
    print(L)


.. parsed-literal::

    [-9, -3, -4, 99, 3, 4, 5, 8, 9, 8, 7, 3, 0, 1]
    [-9, -3, -4, 99, 4, 5, 8, 9, 8, 7, 3, 0, 1]


Tuplas
~~~~~~

Las tuplas son objetos similares a las listas, sobre las que se puede
iterar y seleccionar partes seg√∫n su √≠ndice. La principal diferencia es
que son inmutables mientras que las listas pueden modificarse. Los
ejemplos anteriores del tipo ``L[0] = -9`` resulta en un error si lo
intentamos con tuplas

.. code:: python

    L1 = [0,1,2,3,4,5] # Las listas se definen con corchetes
    T1 = (0,1,2,3,4,5) # Las tuplas se definen con par√©ntesis
    print(L1[2], L1[-3:])
    print(T1[2], T1[-3:])



.. parsed-literal::

    2 [3, 4, 5]
    2 (3, 4, 5)


.. code:: python

    L1[0] =- 1

.. code:: python

    try:
        T1[0] =- 1


::


      File "<ipython-input-22-2d25084c44c9>", line 2
        T1[0] =- 1
                  ^
    SyntaxError: unexpected EOF while parsing



Las tuplas se usan cuando uno quiere crear una ‚Äúvariable‚Äù que no va a
ser modificada. Adem√°s c√≥digos similares con tuplas pueden ser un poco
m√°s r√°pidos que si usan listas.

Un uso com√∫n de las tuplas es el de asignaci√≥n a m√∫ltiples variables

.. code:: python

    a, b, c = (1, 3, 5)

.. code:: python

    print(a,b,c)


.. parsed-literal::

    1 3 5


.. code:: python

    # Los par√©ntesis son opcionales en este caso
    a, b, c = 4, 5, 6
    print(a,b,c)


.. parsed-literal::

    4 5 6


Un uso muy com√∫n es el de intercambiar el valor de dos variables

.. code:: python

    print(a,b)
    a, b = b, a                     # swap 
    print(a,b)


.. parsed-literal::

    4 5
    5 4


Rangos
~~~~~~

Los objetos de tipo
`range <https://docs.python.org/es/3/library/stdtypes.html#ranges>`__
representan una secuencia inmutable de n√∫meros y se usan habitualmente
para ejecutar un bucle
`for <https://docs.python.org/es/3/reference/compound_stmts.html#for>`__
un n√∫mero determinado de veces.

.. code:: python

    range(5)




.. parsed-literal::

    range(0, 5)



Es un tipo que permite f√°cilmente iterar sobre un ‚Äúcontador‚Äù. Veremos
m√°s adelante su uso. Notar que podemos crear una lista (o una tupla) a
partir del tipo ``range``

.. code:: python

    list(range(5))




.. parsed-literal::

    [0, 1, 2, 3, 4]



Ejercicios
~~~~~~~~~~

1. Manejos de listas **utilizando indexado**:

   -  Cree la lista **N** de longitud 50, donde cada elemento es un
      n√∫mero entero de 1 a 50 inclusive (Ayuda: vea la expresi√≥n
      ``range``).
   -  Invierta la lista.
   -  Extraiga una lista **N2** que contenga s√≥lo los elementos pares de
      **N**. (Resultado ``[2, 4, ..., 50]``)
   -  Cree una nueva lista (a partir de **N**) que contenga s√≥lo los
      primeros cinco y los √∫ltimos cinco elementos impares de **N** (el
      resultado esperado es: ``[1,3,5,7,9,41,43,45,47,49]``)

Diccionarios
~~~~~~~~~~~~

Los diccionarios son colecciones de objetos *en principio heterog√©neos*
que no est√°n ordenados y no se refieren por √≠ndice (como ``L1[3]``) sino
por una etiqueta o clave (**key**). Las claves pueden ser cualquier
objeto inmutable (cadenas de caracteres, numeros, tuplas) y los valores
pueden ser cualquier tipo de objeto. Las claves no se pueden repetir
pero los valores s√≠.

.. code:: python

    d0 = {'a': 123}                 # Un diccionario con un s√≥lo elemento

.. code:: python

    d0['a']




.. parsed-literal::

    123



Definimos dos diccionarios, con varios elementos

.. code:: python

    d1 = {'nombre':'Juan', 
          'apellido': 'Garc√≠a', 
          'edad': 10, 
          'direcci√≥n': ['Av Bustillo','9500'], 
          'cod':8400,  
          'ciudad': "Bariloche"}
    d2 = {'nombre':'Pepe', 
          'apellido': 'Garc√≠a', 
          'edad': 109, 
          'direcci√≥n': ['Av Bustillo','9500'], 
          'cod':8400,
          'ciudad': "Bariloche"}

.. code:: python

    len(d1)




.. parsed-literal::

    6



Vemos que estos diccionarios tienen algunos valores que son *strings*,
otros son n√∫meros enteros, y la direcci√≥n tiene como valor una lista.

De la misma manera, podemos crear una lista cuyos elementos son
diccionarios:

.. code:: python

    L1 = [d1, d2]
    L1[0]['nombre']




.. parsed-literal::

    'Juan'



Ac√°, hemos creado una lista de dos elementos, donde cada uno es un
diccionario. Similarmente, podemos crear un diccionario donde cada
elemento es a su vez un diccionario:

.. code:: python

    integrantes = {d1['nombre']: d1, d2['nombre']: d2}

.. code:: python

    integrantes['Pepe']




.. parsed-literal::

    {'nombre': 'Pepe',
     'apellido': 'Garc√≠a',
     'edad': 109,
     'direcci√≥n': ['Av Bustillo', '9500'],
     'cod': 8400,
     'ciudad': 'Bariloche'}



.. code:: python

    # Agregamos un nuevo elemento al diccionario (que es otro diccionario)
    d1['tel'] = {'cel':1213, 'fijo':23848}

.. code:: python

    d1




.. parsed-literal::

    {'nombre': 'Juan',
     'apellido': 'Garc√≠a',
     'edad': 10,
     'direcci√≥n': ['Av Bustillo', '9500'],
     'cod': 8400,
     'ciudad': 'Bariloche',
     'tel': {'cel': 1213, 'fijo': 23848}}



Como las componentes del diccionario ``integrantes`` eran ``d1`` y
``d2``, al modificar ``d1`` tambi√©n estamos modificando ``integrantes``

.. code:: python

    integrantes['Juan']




.. parsed-literal::

    {'nombre': 'Juan',
     'apellido': 'Garc√≠a',
     'edad': 10,
     'direcci√≥n': ['Av Bustillo', '9500'],
     'cod': 8400,
     'ciudad': 'Bariloche',
     'tel': {'cel': 1213, 'fijo': 23848}}



Los diccionarios pueden pensarse como pares *key*, *valor*. Para obtener
todas las claves (*keys*), valores, o pares (clave, valor) usamos:

.. code:: python

    print ('\n' + 70*'+' + '\n\tkeys:')
    print (list(d1.keys()))
    print ('\n' + 70*'+'+ '\n\tvalues:')
    print (list(d1.values()))
    print ('\n' + 0*'+'+ '\n\titems:')
    print (list(d1.items()))


.. parsed-literal::

    
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    	keys:
    ['nombre', 'apellido', 'edad', 'direcci√≥n', 'cod', 'ciudad', 'tel']
    
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    	values:
    ['Juan', 'Garc√≠a', 10, ['Av Bustillo', '9500'], 8400, 'Bariloche', {'cel': 1213, 'fijo': 23848}]
    
    
    	items:
    [('nombre', 'Juan'), ('apellido', 'Garc√≠a'), ('edad', 10), ('direcci√≥n', ['Av Bustillo', '9500']), ('cod', 8400), ('ciudad', 'Bariloche'), ('tel', {'cel': 1213, 'fijo': 23848})]


Arrays de Numpy
~~~~~~~~~~~~~~~

Un paquete (incluyendo varios m√≥dulos) que es muy importante en el uso
de Python para ciencias e ingenier√≠as es `Numpy <http://numpy.org>`__.
Como con todos los m√≥dulos, se carga utilizando la palabra ``import``.

Existen variantes en la manera de importar los m√≥dulos que son
‚Äúequivalentes‚Äù. En este caso le vamos a dar un alias que sea m√°s corto
de tipear, este es el procedimiento habitual y es la manera en que van a
encontrarlo usualmente en ejemplos si buscan ayuda *online*.

.. code:: python

    # Esta es la manera m√°s usada de importar este m√≥dulo. 
    import numpy as np

.. code:: python

    L = list(range(0,6))
    x = np.array(range(6))

.. code:: python

    type(L), type(x)




.. parsed-literal::

    (list, numpy.ndarray)



.. code:: python

    L




.. parsed-literal::

    [0, 1, 2, 3, 4, 5]



.. code:: python

    x




.. parsed-literal::

    array([0, 1, 2, 3, 4, 5])



.. code:: python

    L == x




.. parsed-literal::

    array([ True,  True,  True,  True,  True,  True])



Como vemos, - ``L`` es una **lista** con los n√∫meros naturales de 0 a 5
- ``x`` es un **array** con los mismos n√∫meros.

Nos referiremos al tipo de ``x`` como **array**, **numpy.array** o
**numpy.ndarray** (o np.array, np.ndarray)

Veamos c√≥mo se comparan los *arrays* y las *listas*:

.. code:: python

    # Multiplicaci√≥n de arrays y listas por un entero
    print( 3*x )
    print( 3*L )


.. parsed-literal::

    [ 0  3  6  9 12 15]
    [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5]


.. code:: python

    # Suma de dos arrays o dos listas
    print( x + x )
    print( L + L )


.. parsed-literal::

    [ 0  2  4  6  8 10]
    [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5]


Mientras que la suma entre listas est√° definida (igual que para strings)
como la concatenaci√≥n, para arrays la suma (y todas las operaciones) se
definen elemento a elemento.

Control de flujo
----------------

if/elif/else
~~~~~~~~~~~~

En todo lenguaje necesitamos controlar el flujo de una ejecuci√≥n segun
una condici√≥n Verdadero/Falso (booleana). *Si (condicion) es verdadero
hac√© (bloque A); Sino hac√© (Bloque B)*. En pseudo c√≥digo:

::

       Si condici√≥n 1:
           bloque A
       sino y condici√≥n 2:
           bloque B
       sino:
           bloque C

y en Python es muy parecido!

.. code:: python

      if condici√≥n_1:
        bloque A
      elif condicion_2:
        bloque B
      elif condicion_3:
        bloque C
      else:
        Bloque final

En un ``if``, la conversi√≥n a tipo *boolean* es impl√≠cita. El tipo
``None`` (vac√≠o), el ``0``, una secuencia (lista, tupla, string) (o
conjunto o diccionario, que ya veremos) vac√≠a siempre evalua a
``False``. Cualquier otro objeto evalua a ``True``.

Podemos tener multiples condiciones. Se ejecutar√° el primer bloque cuya
condici√≥n sea verdadera, o en su defecto el bloque ``else``. Esto es
equivalente a la sentencia ``switch`` de otros lenguajes.

.. code:: python

    Nota = 7
    if Nota >= 8:
        print ("Aprob√≥ c√≥modo, felicidades!")
    elif 6 <= Nota < 8:
        print ("Bueno, al menos aprob√≥!")
    elif (4 <= Nota) and (Nota < 6) :
        print ("Bastante bien, pero no le alcanz√≥")
    else:
        print("Debe esforzarse m√°s!")


.. parsed-literal::

    Bueno, al menos aprob√≥!


Iteraciones
~~~~~~~~~~~

Sentencia for
^^^^^^^^^^^^^

Otro elemento de control es el que permite *iterar* sobre una secuencia
(o *‚Äúiterador‚Äù*). Obtener cada elemento para hacer algo. En Python se
logra con la sentencia ``for``. En lugar de iterar sobre una condici√≥n
aritm√©tica hasta que se cumpla una condici√≥n (como en C o en Fortran) en
Python la sentencia ``for`` itera sobre los √≠tems de una secuencia en
forma ordenada

.. code:: python

    Lista = ['auto', 'casa', "perro", "gato", "√°rbol", "lechuza", "banana"]
    for L in Lista:
      print(L)


.. parsed-literal::

    auto
    casa
    perro
    gato
    √°rbol
    lechuza
    banana


Iterando sobre una lista podemos actuar de la manera que necesitemos

.. code:: python

    for L in Lista:
        print(f'En la palabra {L} hay {L.count("a")} letras "a"')
        
    print(f'\nLa palabra m√°s larga es {max(Lista, key=len)}')


.. parsed-literal::

    En la palabra auto hay 1 letras "a"
    En la palabra casa hay 2 letras "a"
    En la palabra perro hay 0 letras "a"
    En la palabra gato hay 1 letras "a"
    En la palabra √°rbol hay 0 letras "a"
    En la palabra lechuza hay 1 letras "a"
    En la palabra banana hay 3 letras "a"
    
    La palabra m√°s larga es lechuza


En estos ejemplos, en cada iteraci√≥n ``L`` toma sucesivamente los
valores de ``Lista``. La primera vez es ``L='auto'``, la segunda
``L='casa'``, ‚Ä¶ El cuerpo del *loop* ``for``, como todos los bloques en
**Python** est√° definido por la **indentaci√≥n**. La √∫ltima l√≠nea est√°
fuera del loop y se ejecuta al terminar todas las iteraciones del
``for``.

Veamos otro ejemplo, donde iteramos sobre un ``range`` actuando como
‚Äúcontador‚Äù:

.. code:: python

    for elemento in range(10):
        print(elemento, end=', ')



.. parsed-literal::

    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 

En este ejemplo la funci√≥n range devuelve en cada iteraci√≥n un contador
que se inicia en 0 y termina en 10. Si bien esto nos permite trabajar de
la manera usual en otros lenguajes iterando sobre un contador y
eligiendo el elemento por su √≠ndice en la forma ``Lista[i]``, en Python
es mucho m√°s simple, claro y eficiente hacerlo como lo hicimos
anteriormente. Compare la forma ‚Äúequivocada‚Äù con el ejemplo anterior:

.. code:: python

    # ESTE BLOQUE NOOOOOO!
    m = 0
    indice=0
    for i in range(len(Lista)):
        print(f'En la palabra {Lista[i]} hay {Lista[i].count("a")} letras "a"')
        if len(Lista[i]) > m: 
            m = len(Lista[i])
            indice = i
        
    print(f'\nLa palabra m√°s larga es {Lista[indice]}')    



.. parsed-literal::

    En la palabra auto hay 1 letras "a"
    En la palabra casa hay 2 letras "a"
    En la palabra perro hay 0 letras "a"
    En la palabra gato hay 1 letras "a"
    En la palabra √°rbol hay 0 letras "a"
    En la palabra lechuza hay 1 letras "a"
    En la palabra banana hay 3 letras "a"
    
    La palabra m√°s larga es lechuza


Esta no es la manera ‚Äúcorrecta‚Äù en Python, ya que estamos usando la
lista para determinar el contador, que a su vez se usa como √≠ndice para
determinar el elemento de la lista. En la primera versi√≥n
(``for L in Lista:``) directamente tenemos el elemento.

Ejercicios
----------

1. Cree una lista de la forma ``L = [1,3,5,...,17,19,19,17,...,3,1]``

2. Utilizando el string:

.. code:: python

   s1='En un lugar de la Mancha de cuyo nombre no quiero acordarme'

y utilizando funciones y `m√©todos de
strings <https://docs.python.org/es/3/library/stdtypes.html#string-methods>`__:

-  Obtenga la cantidad de caracteres.

-  Imprima la frase anterior pero con cada palabra empezando en
   may√∫sculas.

-  Cuente cuantas letras ‚Äòa‚Äô tiene la frase, ¬øcu√°ntas vocales tiene?

-  Imprima el string ``s1`` centrado en una l√≠nea de 80 caracteres,
   rodeado de guiones en la forma:

   ``----------En un lugar de la Mancha de cuyo nombre no quiero acordarme-----------``

-  Obtenga una lista **L1** donde cada elemento sea una palabra.

   -  Cuente la cantidad de elementos en ``L1`` (utilizando python).
   -  Ordene la lista **L1** en orden alfab√©tico.
   -  Ordene la lista **L1** tal que las palabras m√°s cortas est√©n
      primero.
   -  Ordene la lista **L1** tal que las palabras m√°s largas est√©n
      primero.
   -  Construya un string **s2** con la lista del resultado del punto
      anterior.
   -  Encuentre la palabra m√°s larga y la m√°s corta de la frase.

3. Usando estructuras de control, calcule la suma:

   .. math::  s_{1} = \frac{1}{2} \left(\sum_{k=1}^{100}k^{-1} \right)

   1. Incluyendo todos los valores de ``k``
   2. Incluyendo √∫nicamente los valores pares de ``k``.


