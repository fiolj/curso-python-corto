.. _clase_01:

Clase 1: Conceptos básicos de Python 
======================================


Características generales del lenguaje
--------------------------------------

Python presenta características modernas. Posiblemente su característica
más visible/notable es que la estructuración del código está fuertemente
relacionada con su legibilidad:

-  Es un lenguaje interpretado (no se compila separadamente)

-  Provee tanto un entorno interactivo como de programas separados

-  Las funciones, bloques, ámbitos están definidos por la indentación

-  Tiene una estructura altamente modular, permitiendo su reusabilidad

-  Es un lenguaje de *tipeado dinámico*, no tenemos que declarar el tipo
   de variable antes de usarla.

Python es un lenguaje altamente modular con una biblioteca standard que
provee de funciones y tipos para un amplio rango de aplicaciones, y que
se distribuye junto con el lenguaje. Además hay un conjunto muy
importante de utilidades que pueden instalarse e incorporarse muy
fácilmente. El núcleo del lenguaje es pequeño, existiendo sólo unas
pocas palabras reservadas:

====== ======== ======= ======== ======
False  class    finally is       return
====== ======== ======= ======== ======
None   continue for     lambda   try
True   def      from    nonlocal while
and    del      global  not      with
as     elif     if      or       yield
assert else     import  pass     
break  except   in      raise    
====== ======== ======= ======== ======

Además de las palabras reservadas, es relevante el caracter ``#``,
porque inicia un comentario que se continúa hasta el final de la línea.
Los comentarios son fragmentos que se ignoran completamente en la
ejecución del código.

Comentarios
~~~~~~~~~~~

::

   Real programmers don't comment their code.
   It was hard to write, it should be hard to understand.

.. code:: python

    1+1  # Esto es un comentario
    # 3+3




.. parsed-literal::

    2



Como vemos, la segunda línea es ignorada completamente.

Tipos simples de variables
--------------------------

Python es un lenguaje de muy alto nivel y por lo tanto trae muchos
*tipos* de datos ya definidos:

-  Números: enteros, reales, complejos
-  Tipos lógicos (booleanos)
-  Cadenas de caracteres (strings) y bytes
-  Listas: una lista es una colección de cosas, ordenadas, que pueden
   ser todas distintas entre sí
-  Diccionarios: También son colecciones de cosas, pero no están
   ordenadas y son identificadas con una etiqueta
-  Conjuntos, tuples, …

Números
~~~~~~~

Hay varios tipos de números en Python. Aquí definimos y asignamos valor
a distintas variables:

.. code:: python

    a = 13
    b = 1.235
    c = a + b

.. code:: python

    type(a)




.. parsed-literal::

    int



.. code:: python

    print(a, type(a))


.. parsed-literal::

    13 <class 'int'>


.. code:: python

    print(b, type(b))
    print(c, type(c))


.. parsed-literal::

    1.235 <class 'float'>
    14.235 <class 'float'>


Esta es una de las características de Python. Se define el tipo de
variable en forma dinámica, al asignarle un valor.

De la misma manera se cambia el tipo de una variable en forma dinámica,
para poder operar. Por ejemplo en el último caso, la variable ``a`` es
de tipo ``int``, pero para poder sumarla con la variable ``b`` debe
convertirse su valor a otra de tipo ``float``.

.. code:: python

    print(a, type(a))
    a = 1.5 * a
    print (a, type(a))


.. parsed-literal::

    13 <class 'int'>
    19.5 <class 'float'>


.. code:: python

    print(a, b,c)


.. parsed-literal::

    19.5 1.235 14.235


Ahora, la variable ``a`` es del tipo ``float``.

.. note::  La función ``print``
  
  Estuvimos usando, sin hacer ningún comentario, la función
  
  ::
  
     print(arg1, arg2, arg3, ..., sep=' ', end='\n', file=sys.stdout, flush=False)` 
  
  acepta un número variable de argumentos. Imprime por pantalla todos los
  argumentos que se le pasan separados por el string ``sep`` (cuyo valor
  por defecto es un espacio), y termina con el string ``end`` (con valor
  por defecto *newline*).
  
  .. code:: python
  
      print(3,2,'hola')
      print(4,1,'chau')
  
  
  .. parsed-literal::
  
      3 2 hola
      4 1 chau
  
  
  .. code:: python
  
      print(3,2,'hola',sep='++++',end=' -> ')
      print(4,1,'chau',sep='++++')
  
  
  .. parsed-literal::
  
      3++++2++++hola -> 4++++1++++chau
  
  
  .. code:: python
  
      print(3,2,'hola','++++',' -> ')
      print(4,1,'chau','++++')
  
  
  .. parsed-literal::
  
      3 2 hola ++++  -> 
      4 1 chau ++++
  
  
  .. code:: python
  
      print(3,2,'hola',sep=',')
  
  
  .. parsed-literal::
  
      3,2,hola
  
  
  

Números complejos
^^^^^^^^^^^^^^^^^

Los números complejos son parte standard del lenguaje, y las operaciones
básicas que están incorporadas en forma nativa pueden utilizarse
normalmente

.. code:: python

    z1 = 3 + 1j
    z2 = 2 + 2.124j
    z3 = 2j
    print ('z1 =', z1, ', z2 =', z2,' z3 =', z3)


.. parsed-literal::

    z1 = (3+1j) , z2 = (2+2.124j)  z3 = 2j


.. code:: python

    type(z1)




.. parsed-literal::

    complex



.. code:: python

    print('1.5j * z2 + z1 = ', 1.5j * z2 + z1)  # sumas, multiplicaciones de números complejos
    print('z2² = ', z2**2)  # potencia de números complejos
    print('conj(z1) = ',  z1.conjugate()  )


.. parsed-literal::

    1.5j * z2 + z1 =  (-0.18599999999999994+4j)
    z2² =  (-0.5113760000000003+8.496j)
    conj(z1) =  (3-1j)


.. code:: python

    print ('Im(z1) = ', z1.imag)
    print ('Re(z1) = ', z1.real)
    print ('abs(z1) = ', abs(z1))


.. parsed-literal::

    Im(z1) =  1.0
    Re(z1) =  3.0
    abs(z1) =  3.1622776601683795


Operaciones
^^^^^^^^^^^

Las operaciones aritméticas básicas son:

-  adición: ``+``
-  sustracción: ``-``
-  multiplicación: ``*``
-  división: ``/``
-  potencia: ``**``
-  módulo: ``%``
-  división entera: ``//``

Las operaciones se pueden agrupar con parentesis y tienen precedencia
estándar.

División entera (//) significa quedarse con la parte entera de la
división (sin redondear).

.. note::  Las operaciones matemáticas están incluidas en el lenguaje,
  pero las funciones no.
  
  En particular las funciones elementales: trigonométricas, hiperbólicas,
  logaritmos no están incluidas. En todos los casos es fácil utilizarlas
  porque las proveen módulos. Lo veremos pronto.
  
  

.. code:: python

    print('división de 20/3:         ', 20/3)
    print('parte entera de 20/3:     ', 20//3)
    print('fracción restante de 20/3:', 20/3 - 20//3)
    print('Resto de 20/3:            ', 20%3)


.. parsed-literal::

    división de 20/3:          6.666666666666667
    parte entera de 20/3:      6
    fracción restante de 20/3: 0.666666666666667
    Resto de 20/3:             2


En Python 3 la división entre números enteros da como resultado un
número flotante

.. code:: python

    print(20/5)
    print(type(20/5))
    print(20/3)


.. parsed-literal::

    4.0
    <class 'float'>
    6.666666666666667


.. warning::  En *Python 2.x* la división entre números enteros es
  entera
  
  .. code:: python
  
      %%python2
      print 1/2,  20/3
  
  
  .. parsed-literal::
  
      0 6
  
  
  .. code:: python
  
      print( 1//2,  20//3)  # División entera 
      print( 1/2,  20/3)    # División
  
  
  .. parsed-literal::
  
      0 6
      0.5 6.666666666666667
  
  
  

Tipos simples: Booleanos
~~~~~~~~~~~~~~~~~~~~~~~~

Los tipos lógicos o *booleanos*, pueden tomar los valores *Verdadero* o
*Falso* (``True`` o ``False``). También hay un tipo *especial*, el
elemento ``None``.

.. code:: python

    t = False
    print('¿t is True?', t == True)
    print('¿t is False?', t == False)


.. parsed-literal::

    ¿t is True? False
    ¿t is False? True


Los valores se pueden asignar a variables, como se hace con números

.. code:: python

    c = (t == True)
    print('¿t is True?', c)
    print (type(c))


.. parsed-literal::

    ¿t is True? False
    <class 'bool'>


El tipo ``None`` no es un número, pero tampoco es Verdadero o Falso

.. code:: python

    print ('True == None: ',True == None)
    print ('False == None: ', False == None)


.. parsed-literal::

    True == None:  False
    False == None:  False


.. code:: python

    a = None
    print ('type(a): ',type(a))
    print (bool(None))

Aquí hemos estado preguntando si dos cosas eran iguales o no (igualdad).
También podemos preguntar si una **es** la otra (identidad). En el
siguiente ejemplo vemos que dos variables pueden tener el mismo valor
pero ser diferentes

.. code:: python

    d = 1.5
    a = d
    print(d == a)
    print(d is a)


.. parsed-literal::

    True
    True


.. code:: python

    d = 1.5
    a = 1.5
    print(d == a)
    print(d is a)


.. parsed-literal::

    True
    False


Sin embargo, dos variables que tienen valores ``True`` son efectivamente
“la misma” (son idénticas). Lo mismo ocurre con ``False`` y ``None``

.. code:: python

    a = True
    b = True
    c = None
    d = None
    print ('a is True: ', a is True)
    print ('c is None: ', c is None)
    print("¿Son idénticas las variables?")
    print ('b is a: ', b is a)
    print ('d is c: ', d is c)


.. parsed-literal::

    a is True:  True
    c is None:  True
    ¿Son idénticas las variables?
    b is a:  True
    d is c:  True


Operadores lógicos
^^^^^^^^^^^^^^^^^^

Los operadores lógicos en Python son muy explicitos:

::

   A == B  (A igual que B)
   A > B   (A mayor que B)
   A < B   (A menor que B)
   A >= B  (A igual o mayor que B)
   A <= B  (A igual o menor que B)
   A != B  (A diferente que B)
   A in B  (A incluido en B)
   A is B  (Identidad: A es el mismo elemento que B)

y a todos los podemos combinar con ``not``, que niega la condición

.. code:: python

    print ('¿20/3 == 6?  ->', 20/3 == 6)
    print ('¿20//3 == 6? ->', 20//3 == 6)
    print ('¿20//3 >= 6? ->', 20//3 >= 6)
    print ('¿20//3 > 6?  ->', 20//3 > 6)


.. parsed-literal::

    ¿20/3 == 6?  -> False
    ¿20//3 == 6? -> True
    ¿20//3 >= 6? -> True
    ¿20//3 > 6?  -> False


.. code:: python

    a = 1001
    b = 1001
    print ('a == b     ->', a == b)
    print ('a is b     ->', a is b)
    print ('a is not b ->', a is not b)


.. parsed-literal::

    a == b     -> True
    a is b     -> False
    a is not b -> True


Note que en las últimas dos líneas estamos fijándonos si las dos
variables son la misma (identidad), y no ocurre aunque sus valores son
iguales.

Modularización y reuso
----------------------

Los módulos son el mecanismo de Python para reusar código. Una gran
ventaja del lenguaje es que ya existen muchos módulos que son parte de
la biblioteca *standard*. Además, existen numerosas bibliotecas y
módulos para ayudarnos en cualquier tarea.

El uso de los módulos es muy simple, para poder aprovecharlo
necesitaremos saber dos cosas:

-  Qué funciones están ya definidas y listas para usar
-  Cómo acceder a ellas

La primera pregunta: cómo saber cuáles son los posibles módulos que ya
están definidos, su nombre, y que funciones están disponibles tiene una
respuesta muy general que es “buscar” (en internet). La primera
respuesta que podemos (deberíamos) intentar es: la
`documentación <https://docs.python.org/es/3/index.html>`__, y en
particular la `biblioteca
standard <https://docs.python.org/es/3/library/index.html>`__.

La segunda cuestión: una vez que sabemos qué existe (y no necesitamos
reinventar), cómo podemos usarlo:

Para utilizar todas las funcionalidades que están definidas en un
*modulo* debemos primero hacerle saber a nuestro programa que existen.
Eso se hace *importando* el módulo con el simple comando
``import modulo``, donde modulo es el nombre que queremos importar.

Una vez importado, podemos utilizar constantes y funciones definidas en
el módulo con la notación “de punto”: ``modulo.funcion()``.

Ejemplos: Módulos math y cmath
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

El módulo `math <https://docs.python.org/es/3/library/math.html>`__
contiene funciones y utilidades para trabajar con números reales
(enteros y punto flotante). Es parte de la biblioteca standard de Python
por lo que no tenemos que instalar nada nuevo. Contiene todas las
funciones más comunes (trigonométricas, exponenciales, logaritmos, etc)
y algunas constantes importantes (:math:`\pi`, e, etc). En realidad es
una interface para dar acceso a la biblioteca ``math`` en C.

Veamos como utilizarlo:

.. code:: python

    import math

Después de este comando, tenemos disponible todos los objetos definidos
(por algún amable programador) en el módulo
`math <https://docs.python.org/es/3/library/math.html>`__

.. code:: python

    # Veamos el valor de Pi:
    math.pi




.. parsed-literal::

    3.141592653589793



.. code:: python

    # algunas constantes y funciones elementales
    raiz5pi = math.sqrt(5*math.pi)

.. code:: python

    raiz5pi




.. parsed-literal::

    3.963327297606011



Otras funciones disponibles son ``floor`` y ``ceil``:

.. code:: python

    print (raiz5pi, math.floor(raiz5pi), math.ceil(raiz5pi))
    print (math.e, math.floor(math.e), math.ceil(math.e))


.. parsed-literal::

    3.963327297606011 3 4
    2.718281828459045 2 3


Como puede leerse en la documentación del módulo, se definen también
funciones elementales:

.. code:: python

    # algunas funciones elementales
    print (math.log(1024,2), math.log(27,3))
    print (math.factorial(7), math.factorial(9), math.factorial(10))
    print ('Combinatorio: C(6,2):',math.factorial(6)/(math.factorial(4)*math.factorial(2)))


.. parsed-literal::

    10.0 3.0
    5040 362880 3628800
    Combinatorio: C(6,2): 15.0


.. code:: python

    # algunas funciones elementales
    print (math.log(1024,2), math.log(27,3))
    print (math.factorial(7), math.factorial(9), math.factorial(10))
    print ('Combinatorio: C(6,2):',math.factorial(6/(math.factorial(4)*math.factorial(2)))


::


      Cell In [39], line 4
        print ('Combinatorio: C(6,2):',math.factorial(6/(math.factorial(4)*math.factorial(2)))
                                                                                              ^
    SyntaxError: incomplete input



A veces, sólo necesitamos unas pocas funciones de un módulo. Entonces
para abreviar la notación combiene importar sólo lo que vamos a usar,
usando la notación:

``from xxx import yyy``

.. code:: python

    from math import sqrt, pi, log, floor

.. code:: python

    raiz5pi = sqrt(5*pi)
    print (log(1024, 2))
    print (raiz5pi, floor(raiz5pi))


.. parsed-literal::

    10.0
    3.963327297606011 3


.. note::  Para importar todas las definiciones de un módulo pueden
  encontrar la (perfectamente válida) notación:
  
  ``from xxx import *``
  
  donde el asterisco indica “todo”. Este uso no está recomendado porque
  varios módulos pueden usar los mismos nombres y no sabríamos cuál
  estamos usando. También puede traer inconvenientes si después queremos
  reusar el código que estamos escribiendo.
  
  

Otra opción es utilizar un “alias” para el módulo. Esto permite mantener
información del origen de los objetos sin tener que escribir el nombre
completo

.. code:: python

    import math as m
    m.sqrt(3.2)




.. parsed-literal::

    1.7888543819998317



El módulo ``math`` contiene funciones para trabajar con números reales

.. code:: python

    import math
    try:
        math.sqrt(-1)
    except:
        print("error")


.. parsed-literal::

    error


y falla con números complejos, para ello existe el módulo
`cmath <https://docs.python.org/es/3/library/cmath.html>`__

.. code:: python

    import cmath as c

Ahora tenemos a nuestra disposición todas las utilidades definidas en el
módulo:

.. code:: python

    print('Usando cmath (-1)^0.5: ', c.sqrt(-1))


.. parsed-literal::

    Usando cmath (-1)^0.5:  1j


.. code:: python

    print(c.cos(c.pi/3 + 2j))


.. parsed-literal::

    (1.8810978455418161-3.1409532491755083j)


Si queremos calcular la fase (el ángulo que forma con el eje x) podemos
usar la función phase

.. code:: python

    z = 1 + 1j
    c.phase(z)                  # Resultado en radianes




.. parsed-literal::

    0.7853981633974483



.. code:: python

    z = -1 - 1j
    c.phase(z)                  # Resultado en radianes




.. parsed-literal::

    -2.356194490192345



.. code:: python

    m.degrees(c.phase(z))    # Resultado en grados




.. parsed-literal::

    -135.0



Disgresión: Objetos
-------------------

En python, cualquier elemento es un *objeto*. Todos los objetos tienen,
al menos:

-  un tipo,
-  un valor,
-  una identidad.

Además, pueden tener *métodos*, es decir funciones asociadas que,
habitualmente, actúan sobre el objeto que la posee. Veamos algunos
ejemplos cotidianos:

.. code:: python

    z = 1 + 1j
    print(z, type(z))
    print( z.real )
    print( z.imag )
    print( z.conjugate )
    print( z.conjugate() )

Los números complejos tienen un valor (en este caso :math:`1 + i`), pero
además tienen más información (su parte real, imaginaria) y una función
que nos da su conjugado.

Los números enteros, más simples, también son objetos, con propiedades y
métodos:

.. code:: python

    a = 3                           # Números enteros
    print(type(a))
    a.bit_length()

:math:`3 = 1 * 2^1 + 1 * 2^0`. Entonces en binario 3 se escribe como 11

.. code:: python

    a = 12312
    print(type(a))
    a.bit_length()

En estos casos, usamos el método ``bit_length`` de los enteros, que nos
dice cuántos bits son necesarios para representar el número.

Ejercicios (a)
--------------

1. Para el número complejo :math:`z= 1 + 0.5 i`

   -  Calcular :math:`z^2, z^3, z^4, z^5.`
   -  Calcular los complejos conjugados de :math:`z`, :math:`z^2` y
      :math:`z^3`.
   -  Escribir :math:`z`, :math:`z^2` y :math:`z^3` en coordenadas
      polares.

   (Recuerde que puede utilizar los módulos ``math`` y/o ``cmath``)

Tipos compuestos
----------------

En Python, además de los tipos simples (números y booleanos, entre
ellos) existen tipos compuestos, que pueden contener más de un valor de
algún tipo. Entre los tipos compuestos más importantes vamos a
referirnos a:

-  | `Strings <https://docs.python.org/es/3/library/stdtypes.html#text-sequence-type-str>`__
   | Se pueden definir con comillas dobles ( ” ), comillas simples ( ’
     ), o tres comillas (simples o dobles). Comillas (dobles) y comillas
     simples producen el mismo resultado. Sólo debe asegurarse que se
     utiliza el mismo tipo para abrir y para cerrar el *string*
   | Ejemplo: ``s = "abc"`` (el elemento ``s[0]`` tiene el valor
     ``"a"``).

-  | `Listas <https://docs.python.org/es/3/library/stdtypes.html#sequence-types-list-tuple-range>`__
   | Las listas son tipos que pueden contener más de un elemento de
     cualquier tipo. Los tipos de los elementos pueden ser diferentes.
     Las listas se definen separando los diferentes valores con comas,
     encerrados entre corchetes. Se puede referir a un elemento por su
     índice.
   | Ejemplo: ``L = ["a",1, 0.5 + 1j]`` (el elemento ``L[0]`` es igual
     al *string* ``"a"``).

-  | `Tuplas <https://docs.python.org/es/3/library/stdtypes.html#sequence-types-list-tuple-range>`__
   | Las tuplas se definen de la misma manera que las listas pero con
     paréntesis en lugar de corchetes. Ejemplo:
     ``T = ("a",1, 0.5 + 1j).``

-  | `Diccionarios <https://docs.python.org/es/3/library/stdtypes.html#mapping-types-dict>`__
   | Los diccionarios son contenedores a cuyos elementos se los
     identifica con un nombre (*key*) en lugar de un índice. Se los
     puede definir dando los pares ``key:value`` entre llaves
   | Ejemplo: ``D = {'a': 1, 'b': 2, 1: 'hola', 2: 3.14}`` (el elemento
     ``D['a']`` es igual al número 1).

-  | `Numpy
     Arrays <https://numpy.org/doc/stable/user/absolute_beginners.html#what-is-an-array>`__
   | Los *arrays* de
     `Numpy <https://numpy.org/doc/stable/user/whatisnumpy.html>`__ son
     vectores (multidimensionales) que están optimizados para cálculos.
     Sus elementos deben ser todos del mismo tipoy pueden accederse por
     índice en una misma similar que a los *strings*, *listas* y
     *tuples*
   | Ejemplo: ``A = numpy.array([1., 2., 3.])`` (el elemento ``A[0]`` es
     igual al número 1).

Strings: Secuencias de caracteres
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Una cadena o *string* es una **secuencia** de caracteres (letras,
“números”, símbolos).

Se pueden definir con comillas, comillas simples, o tres comillas
(simples o dobles). Comillas (normales) y comillas simples producen el
mismo resultado. Sólo debe asegurarse que se utiliza el mismo tipo para
abrir y para cerrar el *string*

.. code:: python

    saludo = 'Hola Mundo'
    otro= "that's all"
    dijo = 'Él dijo: "hola" y yo no dije nada'

.. code:: python

    print(saludo)

.. code:: python

    print(otro)

.. code:: python

    print(dijo)

.. note::  Python trabaja con una codificación (*UTF-8*) por lo que
  reconoce nativamente un amplio rango de caracteres
  
  .. code:: python
  
      label = "σ = λ T/ µ + π · δξ."
      print('tipo de label: ', type(label))
      print ('Resultados corresponden a:', label, ' (en m²)')
  
  

Tres comillas (simples o dobles) sirven para incluir una cadena de
caracteres en forma textual, incluyendo saltos de líneas.

.. code:: python

    Texto_largo = '''Aquí me pongo a cantar
    Al compás de la vigüela,
    Que el hombre que lo desvela
    Una pena estraordinaria
    Como la ave solitaria
    Con el cantar se consuela.'''

.. code:: python

    print(Texto_largo)

Operaciones
^^^^^^^^^^^

En **Python** ya hay definidas algunas operaciones como suma
(composición o concatenación), producto por enteros (repetición).

Suma de *strings*
'''''''''''''''''

La suma entre dos cadenas de caracteres está definida y el resultado es
una nueva cadena, conteniendo la concatenación de los dos sumandos

.. code:: python

    s = saludo + " ----> [" + dijo + "] <---- chau"
    print(s)

.. code:: python

    saludo + 'chau'

Multiplicación por un entero
''''''''''''''''''''''''''''

La multiplicación de un número entero ``n`` por un string ``s`` está
definida como “n veces s”

.. code:: python

    print( saludo )
    print( 2*saludo )
    print( 10*"+" + 2* ( saludo + "," ) + 10*"+" + 2*"\n" + "Chau" )

Notar que (obviamente) hay una diferencia entre un número y un string
cuyo valor podemos interpretar como el número. Acá, la variable ``a`` es
un *string* y ``b`` en un número entero

.. code:: python

    a = '1'
    b = 1
    print(a, type(a))
    print(b, type(b))

En consecuencia, las operaciones tienen distinto significado:

.. code:: python

    print(a)
    print ( a + a )
    print ( 3*a )
    print ( a*3 )

.. code:: python

    print(b)
    print ( b + b )
    print ( 3*b )
    print ( b*3 )

También podemos calcular la longitud de un *string* con la función
``len()``

.. code:: python

    saludo, len(saludo)

Utilizando esta función podemos hacer un centrado de texto “manual”

.. code:: python

    n = int((30-len(saludo)//2)) 
    print (n*'*', saludo, n*'*')

.. code:: python

    ntext = "Nuevo texto que queremos centrar"
    n = int((30-len(ntext)//2)) 
    print (n*'<', ntext,n*'>')

Indexado de *strings*
^^^^^^^^^^^^^^^^^^^^^

Los *strings* poseen varias cualidades y funcionalidades. Por ejemplo:

-  Se puede iterar sobre ellos, o quedarse con una parte (slicing)
-  Tienen métodos (funciones que se aplican a su *dueño*)

Podemos referirnos a un caracter o una parte de una cadena de caracteres
mediante su índice. Los índices en **Python** empiezan en 0.

.. code:: python

    saludo, saludo[0], saludo[3]

.. code:: python

    s = "0123456789"
    print ('Primer caracter  :', s[0])
    print ("Segundo caracter :", s[1])
    print ("El último caracter :", s[-1])
    print ("El anteúltimo caracter :", s[-2])

También podemos elegir un subconjunto de caracteres, usando la notación
``s[i:f:p]``

.. code:: python

    print ('El tercer caracter:         ', s[3])
    print ('Los tres primeros:          ', s[0:3])
    print ('Los tres primeros:          ', s[:3])
    print ('Todos a partir del tercero: ', s[3:])
    print ('Los últimos dos:            ', s[-2:])
    print ('Todos menos los últimos dos:', s[:-2])

Estas “subcadenas” son cadenas de caracteres, y por lo tanto pueden
utilizarse de la misma manera que cualquier otra cadena:

.. code:: python

    print (s[:3] + s[-2:])

La selección de elementos y subcadenas de una cadena ``s`` tiene la
forma ``s[i:f:p]`` donde ``i, f, p`` son enteros. La notación se refiere
a la subcadena empezando en el índice ``i``, hasta el índice ``f``
recorriendo con paso ``p``. Casos particulares de esta notación son:

-  Un índice simple. Por ejemplo ``s[3]`` se refiere al tercer elemento
-  Un índice negativo se cuenta desde el final, empezando desde ``-1``
-  Si el paso ``p`` no está presente el valor por defecto es 1. Ejemplo:
   ``s[2:4] = s[2:4:1]``
-  Si se omite el primer índice, el valor asumido es 0. Ejemplo:
   ``s[:2:1] = s[0:2:1]``
-  Si se omite el segundo índice, el valor asumido es -1. Ejemplo:
   ``s[1::1] = s[1:-1:1]``
-  Notar que puede omitirse más de un índice. Ejemplo:
   ``s[::2] = s[0:-1:2]``

.. code:: python

    print (s[:7])
    print (s[:7:2])
    print (s[::-1])
    t = s[::-3]

.. code:: python

    t

Formato de *strings*
^^^^^^^^^^^^^^^^^^^^

Existen varias maneras de aplicar formato a una cadena de caracteres.
Vamos a ver dos opciones: - Uso del método ``format`` - Uso de
“f-strings”

.. code:: python

    from math import pi
    s1 = "El valor de π es {}"

.. code:: python

    "El valor de π es {}".format(pi)

.. code:: python

    s1

.. code:: python

    s1.format(pi)

.. code:: python

    h = 7    # Hora
    T = 5.2  # Temperatura en grados
    s2 = "La temperatura a las {} horas era {} grados".format(h, T)

.. code:: python

    print(s2)

Aquí definimos un *string* llamado ``s3``, donde utilizamos el valor de
la variable pi (definida en el módulo math) para completar el valor.

.. code:: python

    s3 = s1.format(pi)
    print(s3)

En su versión más simple la función ``format`` reemplaza el lugar entre
llaves por el valor dado, en este caso un número. Esta función permite
más de un argumento, y reemplaza operaciones por su resultado, como en
el siguiente ejemplo:

.. code:: python

    s2 = "El valor de π es {} y su doble es {}".format(pi, 2*pi)
    print(s2)

El mismo efecto se puede obtener utilizando interpolación literal
(“f-strings”)

.. code:: python

    s1 = f"El valor de π es {pi}"
    s2 = f"El valor de π es {pi} y su doble es {2*pi}"

.. code:: python

    print(s1)
    print(s2)

Notar que no es necesario definir una variable previamente para imprimir
un string. Los ejemplos anteriores pueden escribirse:

.. code:: python

    print( f"El valor de π es {pi} y su doble es {2*pi}" )
    print( "El valor de π es {} y su doble es {}".format(pi, 2*pi) )

Para controlar el formato de los strings existe una notación específica
que se puede indicar dentro de las llaves tanto para el `método
format <https://docs.python.org/es/3/library/string.html#formatstrings>`__
como para los
`“f-strings” <https://docs.python.org/es/3/reference/lexical_analysis.html#f-strings>`__.
En su versión más simple se agregan “:” (dos puntos) seguidos del
formato deseado. Por ejemplo para imprimir con sólo cuatro decimales
podemos escribir:

.. code:: python

    print("El valor de π con cuatro decimales es {:.4f}".format(pi))
    print(f"El valor de π con cuatro decimales es {pi:.4f}")

Métodos de Strings
^^^^^^^^^^^^^^^^^^

Métodos son “funciones” que actúan sobre el mismo objeto y son parte de
su definición.

Por ejemplo, cuando uno define un *string*, ya está en la definición
incluida la información sobre como realizar algunas operaciones.

Veamos algunos de los métodos definidos sobre *strings*:

.. code:: python

    a = "La mar estaba serena!"
    print(a)

En python existe un método ``replace()`` que hace que sea muy fácil
reemplazar una subcadena por otra:

.. code:: python

    b = a.replace('e','a')
    print(b)

Separar las palabras:

.. code:: python

    b.split()

.. code:: python

    b.split('a')

Estos son métodos que tienen definidos **todos** los *strings*.

Un método es una función que está definida junto con el objeto. En este
caso el string. Hay más información sobre los métodos de las cadenas de
caracteres en: `String
Methods <https://docs.python.org/3/library/stdtypes.html#string-methods>`__

Veamos algunos ejemplos más:

.. code:: python

    # Definimos dos strings
    a = 'Hola Mundo!'
    b = "Somos los colectiveros que cumplimos nuestro deber!"

Buscar y reemplazar cosas en un string:

.. code:: python

    # find nos da el índice del lugar en el string donde se encuentra el substring dado
    b.find('le')

.. code:: python

    print (b)
    print (b.replace('que','y')) # Reemplazamos un substring

.. code:: python

    b.center(70,' ')

.. code:: python

    b.center(70, "*")

Para encontrar información sobre un ``comando`` en las *notebooks*
podemos usar la notación ``comando?``. Por ejemplo, si queremos saber
como funciona el método ``find`` de los strings, usamos (recordar que
definimos antes ``b`` como un *string*):

.. code:: python

    b.find?

Ejercicios (b)
~~~~~~~~~~~~~~

2. Escribir un programa, utilizando formateo de strings, que escriba las
   frases:

   -  “El conjugado de z=1+0.5j es 1-0.5j”
   -  “El conjugado de z=(1+0.5j)^2 es …” (con el valor correspondiente)
   -  “El conjugado de z=(1+0.5j) :math:`\pi` es …” (con el valor
      correspondiente sólo hasta el tercer decimal incluido)

Conversión de tipos
~~~~~~~~~~~~~~~~~~~

Como comentamos anteriormente, y se ve en los ejemplos anteriores, uno
no define el tipo de variable *a-priori* sino que queda definido al
asignársele un valor (por ejemplo ``a=3`` define a como una variable del
tipo entero).

Si bien **Python** hace la conversión de tipos de variables en algunos
casos, **no hace magia**, no puede adivinar nuestra intención si no la
explicitamos.

.. code:: python

    a = 3                           # a es entero
    b = 3.1                         # b es real
    c = 3 + 0j                      # c es complejo
    print (f"a es de tipo {type(a)}\nb es de tipo {type(b)}\nc es de tipo {type(c)}")
    print (f"'a + b' es de tipo {type(a+b)} y 'a + c' es de tipo {type(a+c)}")

.. code:: python

    try:
        print (1 + '1')

Sin embargo, si le decimos explícitamente qué conversión queremos, todo
funciona bien

.. code:: python

    print (str(1) + '1')
    print (1 + int('1'))
    print (1 + float('1.e5'))
    print ("x=" + str(1.e5))
    print ('x=' + str(1.e-5))

.. code:: python

    # a menos que nosotros **nos equivoquemos explícitamente**
    try:
        print (int('z'))

Listas
~~~~~~

Las listas son tipos compuestos, donde todos sus elementos pueden ser
del mismo tipo o no. Algunas características de las listas son:

-  Los elementos no son necesariamente homogéneos en tipo

-  Elementos ordenados

-  Acceso mediante un índice

-  El valor de sus elementos pueden modificarse (esto no es cierto para
   *strings* ni *tuplas*)

-  Están definidas operaciones entre Listas, así como algunos métodos

   -  ``x in L`` (¿x es un elemento de L?)
   -  ``x not in L`` (¿x no es un elemento de L?)
   -  ``L1 + L2`` (concatenar L1 y L2)
   -  ``n*L1`` (n veces L1)
   -  ``L1*n`` (n veces L1)
   -  ``L[i]`` (Elemento i-ésimo)
   -  ``L[i:j]`` (Elementos i a j)
   -  ``L[i:j:k]`` (Elementos i a j, elegidos uno de cada k)
   -  ``len(L)`` (longitud de L)
   -  ``min(L)`` (Mínimo de L)
   -  ``max(L)`` (Máximo de L)
   -  ``L.index(x, [i])`` (Índice de x, iniciando en i)
   -  ``L.count(x)`` (Número de veces que aparece x en L)
   -  ``L.append(x)`` (Agrega el elemento x al final)

Veamos algunos ejemplos:

.. code:: python

    cuadrados = [1, 9, 16, 25]

En esta línea hemos declarado una variable llamada ``cuadrados``, y le
hemos asignado una lista de cuatro elementos. En algunos aspectos las
listas son muy similares a los *strings*. Se pueden realizar muchas de
las mismas operaciones en strings, listas y otros objetos sobre los que
se pueden iterar (*iterables*).

Las listas pueden accederse por posición y también pueden rebanarse
(*slicing*)

Los índices pueden ser positivos (empezando desde cero) o negativos
empezando desde -1.

================== == == == ==
cuadrados:         1  9  16 25
================== == == == ==
índices:           0  1  2  3
índices negativos: -4 -3 -2 -1
================== == == == ==

Operaciones sobre listas
^^^^^^^^^^^^^^^^^^^^^^^^

Veamos algunas operaciones que se pueden realizar sobre listas. Por
ejemplo, se puede fácilmente:

-  concatenar dos listas,
-  buscar un valor dado,
-  agregar elementos,
-  borrar elementos,
-  calcular su longitud,
-  invertirla

Empecemos concatenando dos listas, usando el operador “suma”

.. code:: python

    L = [0,1,2,3,4,5]

.. code:: python

    L1 = L+L

.. code:: python

    L1

La multiplicación por un entero actúa igual que en el caso de *strings*

.. code:: python

    2*L == L + L                     # Igualdad de cada uno de los elementos

.. code:: python

    L1.index(3)                      # Índice del elemento de valor 3

.. code:: python

    L1.count(3)                      # Cuenta las veces que aparece el valor "3"

Las listas tienen definidos métodos, que podemos ver con la ayuda
incluida, por ejemplo haciendo ``help(list)``

Si queremos agregar un elemento al final utilizamos el método
``append``:

.. code:: python

    print(L)

.. code:: python

    L.append(8)

.. code:: python

    print(L)

Notar que, como las listas pueden contener cualquier cosa (incluso otras
listas), tratar de agregar una lista al final de otra con el método
``append`` puede dar resultados inesperados

.. code:: python

    L.append([9, 8, 7])
    print(L)

.. code:: python

    a=L.pop(-1)  # pop() devuelve el elemento correspondiente y lo saca de la lista 

.. code:: python

    L

.. code:: python

    a

Si queremos agregar más de un elemento a una lista podemos usar
``extend``

.. code:: python

    L.extend([9,8,7])
    print(L)

o sumar la nueva lista y asignarla a la misma variable

.. code:: python

    L += [3,2,1]         # equivalente a L = L + [3,2,1]
    print(L)

Si queremos insertar un elemento en una posición que no es el final de
la lista, usamos el método ``insert()``. Por ejemplo para insertar el
valor 6 en la primera posición:

.. code:: python

    L.insert(3,99)
    print(L)

En las listas podemos sobreescribir uno o más elementos

.. code:: python

    L[0] = -9
    print(L)

.. code:: python

    print(L)
    L[0:3] = [-2,-3,-4]
    print(L)

.. code:: python

    print(L)
    L.remove(3)                     # Remueve la primera ocurrencia de 3
    print(L)

Tuplas
~~~~~~

Las tuplas son objetos similares a las listas, sobre las que se puede
iterar y seleccionar partes según su índice. La principal diferencia es
que son inmutables mientras que las listas pueden modificarse. Los
ejemplos anteriores del tipo ``L[0] = -9`` resulta en un error si lo
intentamos con tuplas

.. code:: python

    L1 = [0,1,2,3,4,5] # Las listas se definen con corchetes
    T1 = (0,1,2,3,4,5) # Las tuplas se definen con paréntesis
    print(L1[2], L1[-3:])
    print(T1[2], T1[-3:])


.. code:: python

    L1[0] =- 1

.. code:: python

    try:
        T1[0] =- 1
        print(f"{T1[0] = }")
    except:
        print('Tuples son inmutables')

Las tuplas se usan cuando uno quiere crear una “variable” que no va a
ser modificada. Además códigos similares con tuplas pueden ser un poco
más rápidos que si usan listas.

Un uso común de las tuplas es el de asignación a múltiples variables

.. code:: python

    a, b, c = (1, 3, 5.2)

.. code:: python

    print(a,b,c)

.. code:: python

    a

.. code:: python

    # Los paréntesis son opcionales en este caso
    a, b, c = 4, 5, 6
    print(a,b,c)

Un uso muy común es el de intercambiar el valor de dos variables

.. code:: python

    print(a,b)
    a, b = b, a                     # swap 
    print(a,b)

Rangos
~~~~~~

Los objetos de tipo
`range <https://docs.python.org/es/3/library/stdtypes.html#ranges>`__
representan una secuencia inmutable de números y se usan habitualmente
para ejecutar un bucle
`for <https://docs.python.org/es/3/reference/compound_stmts.html#for>`__
un número determinado de veces.

.. code:: python

    range(5)

Es un tipo que permite fácilmente iterar sobre un “contador”. Veremos
más adelante su uso. Notar que podemos crear una lista (o una tupla) a
partir del tipo ``range``

.. code:: python

    list(range(5))

Ejercicios (c)
~~~~~~~~~~~~~~

3. Manejos de listas **utilizando indexado**:

   -  Cree la lista **N** de longitud 50, donde cada elemento es un
      número entero de 1 a 50 inclusive (Ayuda: vea la expresión
      ``range``).
   -  Invierta la lista.
   -  Extraiga una lista **N2** que contenga sólo los elementos pares de
      **N**. (Resultado ``[2, 4, ..., 50]``)
   -  Cree una nueva lista (a partir de **N**) que contenga sólo los
      primeros cinco y los últimos cinco elementos impares de **N** (el
      resultado esperado es: ``[1,3,5,7,9,41,43,45,47,49]``)

Diccionarios
~~~~~~~~~~~~

Los diccionarios son colecciones de objetos *en principio heterogéneos*
que no están ordenados y no se refieren por índice (como ``L1[3]``) sino
por una etiqueta o clave (**key**). Las claves pueden ser cualquier
objeto inmutable (cadenas de caracteres, numeros, tuplas) y los valores
pueden ser cualquier tipo de objeto. Las claves no se pueden repetir
pero los valores sí.

.. code:: python

    d0 = {'a': 123}                 # Un diccionario con un sólo elemento

.. code:: python

    d0['a']

Definimos dos diccionarios, con varios elementos

.. code:: python

    d1 = {'nombre':'Juan', 
          'apellido': 'García', 
          'edad': 10, 
          'dirección': ['Av Bustillo','9500'], 
          'cod':8400,  
          'ciudad': "Bariloche"}
    d2 = {'nombre':'Pepe', 
          'apellido': 'García', 
          'edad': 109, 
          'dirección': ['Av Bustillo','9500'], 
          'cod':8400,
          'ciudad': "Bariloche"}

.. code:: python

    len(d1)

Vemos que estos diccionarios tienen algunos valores que son *strings*,
otros son números enteros, y la dirección tiene como valor una lista.

De la misma manera, podemos crear una lista cuyos elementos son
diccionarios:

.. code:: python

    L1 = [d1, d2]
    L1[0]['nombre']

Acá, hemos creado una lista de dos elementos, donde cada uno es un
diccionario. Similarmente, podemos crear un diccionario donde cada
elemento es a su vez un diccionario:

.. code:: python

    integrantes = {d1['nombre']: d1, d2['nombre']: d2}

.. code:: python

    integrantes

.. code:: python

    integrantes['Pepe']

.. code:: python

    d1

.. code:: python

    d1['cod']

.. code:: python

    # Agregamos un nuevo elemento al diccionario (que es otro diccionario)
    d1['tel'] = {'cel':1213, 'fijo':23848}

.. code:: python

    d1

Como las componentes del diccionario ``integrantes`` eran ``d1`` y
``d2``, al modificar ``d1`` también estamos modificando ``integrantes``

.. code:: python

    integrantes['Juan']

Los diccionarios pueden pensarse como pares *key*, *valor*. Para obtener
todas las claves (*keys*), valores, o pares (clave, valor) usamos:

.. code:: python

    print ('\n' + 70*'+' + '\n\tkeys:')
    print (list(d1.keys()))
    print ('\n' + 70*'+'+ '\n\tvalues:')
    print (list(d1.values()))
    print ('\n' + 0*'+'+ '\n\titems:')
    print (list(d1.items()))

Arrays de Numpy
~~~~~~~~~~~~~~~

Un paquete (incluyendo varios módulos) que es muy importante en el uso
de Python para ciencias e ingenierías es `Numpy <http://numpy.org>`__.
Como con todos los módulos, se carga utilizando la palabra ``import``.

Existen variantes en la manera de importar los módulos que son
“equivalentes”. En este caso le vamos a dar un alias que sea más corto
de tipear, este es el procedimiento habitual y es la manera en que van a
encontrarlo usualmente en ejemplos si buscan ayuda *online*.

.. code:: python

    # Esta es la manera más usada de importar este módulo. 
    import numpy as np

.. code:: python

    L = list(range(0,6))
    x = np.array(range(6))

.. code:: python

    type(L), type(x)

.. code:: python

    L

.. code:: python

    x

.. code:: python

    L == x

Como vemos, - ``L`` es una **lista** con los números naturales de 0 a 5
- ``x`` es un **array** con los mismos números.

Nos referiremos al tipo de ``x`` como **array**, **numpy.array** o
**numpy.ndarray** (o np.array, np.ndarray)

Veamos cómo se comparan los *arrays* y las *listas*:

.. code:: python

    # Multiplicación de arrays y listas por un entero
    print( 3*x )
    print( 3*L )

.. code:: python

    # Suma de dos arrays o dos listas
    print( x + x )
    print( L + L )

Mientras que la suma entre listas está definida (igual que para strings)
como la concatenación, para arrays la suma (y todas las operaciones) se
definen elemento a elemento.

Ejercicios (d)
~~~~~~~~~~~~~~

4. Cree una lista de la forma ``L = [1,3,5,...,17,19,19,17,...,3,1]``

5. Utilizando el string:

.. code:: python

   s1='En un lugar de la Mancha de cuyo nombre no quiero acordarme'

y utilizando funciones y `métodos de
strings <https://docs.python.org/es/3/library/stdtypes.html#string-methods>`__:

-  Obtenga la cantidad de caracteres.

-  Imprima la frase anterior pero con cada palabra empezando en
   mayúsculas.

-  Cuente cuantas letras ‘a’ tiene la frase, ¿cuántas vocales tiene?

-  Imprima el string ``s1`` centrado en una línea de 80 caracteres,
   rodeado de guiones en la forma:

   ``----------En un lugar de la Mancha de cuyo nombre no quiero acordarme-----------``

-  Obtenga una lista **L1** donde cada elemento sea una palabra.

   -  Cuente la cantidad de elementos en ``L1`` (utilizando python).
   -  Ordene la lista **L1** en orden alfabético.
   -  Ordene la lista **L1** tal que las palabras más cortas estén
      primero.
   -  Ordene la lista **L1** tal que las palabras más largas estén
      primero.
   -  Construya un string **s2** con la lista del resultado del punto
      anterior.
   -  Encuentre la palabra más larga y la más corta de la frase.

Control de flujo
----------------

if/elif/else
~~~~~~~~~~~~

En todo lenguaje necesitamos controlar el flujo de una ejecución segun
una condición Verdadero/Falso (booleana). *Si (condicion) es verdadero
hacé (bloque A); Sino hacé (Bloque B)*. En pseudo código:

::

       Si condición 1:
           bloque A
       sino y condición 2:
           bloque B
       sino:
           bloque C

y en Python es muy parecido!

.. code:: python

      if condición_1:
        bloque A
      elif condicion_2:
        bloque B
      elif condicion_3:
        bloque C
      else:
        Bloque final

En un ``if``, la conversión a tipo *boolean* es implícita. El tipo
``None`` (vacío), el ``0``, una secuencia (lista, tupla, string) (o
conjunto o diccionario, que ya veremos) vacía siempre evalua a
``False``. Cualquier otro objeto evalua a ``True``.

Podemos tener multiples condiciones. Se ejecutará el primer bloque cuya
condición sea verdadera, o en su defecto el bloque ``else``. Esto es
equivalente a la sentencia ``switch`` de otros lenguajes.

.. code:: python

    Nota = 8
    if Nota >= 8:
        print ("Aprobó cómodo, felicidades!")
        print ("Usted es el mejor!!!")
    elif 6 <= Nota < 8:
        print ("Bueno, al menos aprobó!")
        print ("Está bien")
    elif (4 <= Nota) and (Nota < 6) :
        print ("Bastante bien, pero no le alcanzó")
    else:
        print("Debe esforzarse más!")
    
    print("Sigamos evaluando")

Iteraciones
~~~~~~~~~~~

Sentencia for
^^^^^^^^^^^^^

Otro elemento de control es el que permite *iterar* sobre una secuencia
(o *“iterador”*). Obtener cada elemento para hacer algo. En Python se
logra con la sentencia ``for``. En lugar de iterar sobre una condición
aritmética hasta que se cumpla una condición (como en C o en Fortran) en
Python la sentencia ``for`` itera sobre los ítems de una secuencia en
forma ordenada

.. code:: python

    Lista = ['auto', 'casa', "perro", "gato", "árbol", "lechuza", "banana"]
    for L in Lista:
        print(L)


.. parsed-literal::

    auto
    casa
    perro
    gato
    árbol
    lechuza
    banana


Iterando sobre una lista podemos actuar de la manera que necesitemos

.. code:: python

    for n in range(4,6):
        print(f"{n:3d} {2*n:3d}")


.. parsed-literal::

      4   8
      5  10


.. code:: python

    y = 2023
    m = 5
    d = 23
    s = f"datos_{y}{m:02d}{d:02d}.dat"

.. code:: python

    print(s)


.. parsed-literal::

    datos_20230523.dat


.. code:: python

    for L in Lista:
        print(f'En la palabra {L}', end="")
        print(f' hay {L.count("a")} letras "a"')
        
    print(f'\nLa palabra más larga es {max(Lista, key=len)}')


.. parsed-literal::

    En la palabra auto hay 1 letras "a"
    En la palabra casa hay 2 letras "a"
    En la palabra perro hay 0 letras "a"
    En la palabra gato hay 1 letras "a"
    En la palabra árbol hay 0 letras "a"
    En la palabra lechuza hay 1 letras "a"
    En la palabra banana hay 3 letras "a"
    
    La palabra más larga es lechuza


En estos ejemplos, en cada iteración ``L`` toma sucesivamente los
valores de ``Lista``. La primera vez es ``L='auto'``, la segunda
``L='casa'``, … El cuerpo del *loop* ``for``, como todos los bloques en
**Python** está definido por la **indentación**. La última línea está
fuera del loop y se ejecuta al terminar todas las iteraciones del
``for``.

Veamos otro ejemplo, donde iteramos sobre un ``range`` actuando como
“contador”:

.. code:: python

    for elemento in range(10):
        print(elemento, end='; ')



.. parsed-literal::

    0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 

En este ejemplo la función range devuelve en cada iteración un contador
que se inicia en 0 y termina en 10. Si bien esto nos permite trabajar de
la manera usual en otros lenguajes iterando sobre un contador y
eligiendo el elemento por su índice en la forma ``Lista[i]``, en Python
es mucho más simple, claro y eficiente hacerlo como lo hicimos
anteriormente. Compare la forma “equivocada” con el ejemplo anterior:

.. code:: python

    # ESTE BLOQUE NOOOOOO!
    m = 0
    indice=0
    for i in range(len(Lista)):
        print(f'En la palabra {Lista[i]} hay {Lista[i].count("a")} letras "a"')
        if len(Lista[i]) > m: 
            m = len(Lista[i])
            indice = i
        
    print(f'\nLa palabra más larga es {Lista[indice]}')    



.. parsed-literal::

    En la palabra auto hay 1 letras "a"
    En la palabra casa hay 2 letras "a"
    En la palabra perro hay 0 letras "a"
    En la palabra gato hay 1 letras "a"
    En la palabra árbol hay 0 letras "a"
    En la palabra lechuza hay 1 letras "a"
    En la palabra banana hay 3 letras "a"
    
    La palabra más larga es lechuza


Esta no es la manera “correcta” en Python, ya que estamos usando la
lista para determinar el contador, que a su vez se usa como índice para
determinar el elemento de la lista. En la primera versión
(``for L in Lista:``) directamente tenemos el elemento.

.. code:: python

    for L in Lista:
        print(f'En la palabra {L} hay {L.count("a")} letras "a"')



.. parsed-literal::

    En la palabra auto hay 1 letras "a"
    En la palabra casa hay 2 letras "a"
    En la palabra perro hay 0 letras "a"
    En la palabra gato hay 1 letras "a"
    En la palabra árbol hay 0 letras "a"
    En la palabra lechuza hay 1 letras "a"
    En la palabra banana hay 3 letras "a"


Funciones
---------

Definición de funciones
~~~~~~~~~~~~~~~~~~~~~~~

Las funciones en **Python**, como en la mayoría de los lenguajes, usan
una notación matemática, con un nombre y uno o más argumentos entre
paréntesis. Por ejemplo, ya usamos varias funciones matemáticas, que
toman como argumento un número o un *array* de números, y devuelven un
número o un array (dependiendo del argumento, y de la función). Lo que
podemos decir es que toman uno o más argumentos y devuelven uno o más
resultados.

.. code:: python

    import math

.. code:: python

    print('cos(1.54) =', math.cos(1.54))


.. parsed-literal::

    cos(1.54) = 0.03079145908246612


Para mostrar como definir nuestras propias funciones, vamos a tomar el
ejercicio de caída libre y encapsulemos el cálculo en una función:

.. code:: python

    help(math.cos)


.. parsed-literal::

    Help on built-in function cos in module math:
    
    cos(x, /)
        Return the cosine of x (measured in radians).
    


.. code:: python

    z_0 = 10                         # altura inicial en m
    g = -9.8                         # aceleración de la gravedad en m/s^2
    def caida(t, v_0):
        """
        Cálculo de velocidad y posición para una partícula en caída libre como función del tiempo
        El tiempo `t` está en segundos
        v_0 es la velocidad inicial
        Devuelve:
        v,h
        donde:
        `v` es la velocidad en m/s
        `h` es la altura en m
        """
        v = v_0 + g * t                     # para aceleración constante
        h = z_0 + v_0 * t + g * t**2 / 2.   # acorde a Newton
        return v, h
    
    a=1                    # Esto no es parte de la definición de la función

Elementos de la definición de funciones:

-  La primera línea:

   -  Se define empezando con la palabra ``def``
   -  Luego se escribe el nombre de la función
   -  A continuación, entre paréntesis se escriben los argumentos
      separados por comas. Si no hay argumentos se dejan los paréntesis
      vacíos
   -  Se finaliza con los dos puntos (``:``)

-  En la segunda línea empieza un string de documentación (opcional pero
   **muy** recomendado)
-  Luego del string de documentación viene el cuerpo de la función (los
   cálculos en este caso)
-  Devuelve lo que viene a continuación de la palabra ``return`` (en
   este caso dos valores)

Si no se escribe explícitamente que devuelve una función, va a devolver
automáticamente ``None``.

Por ejemplo, la función ``print()`` no devuelve nada, sólo imprime por
pantalla

.. code:: python

    a = print('hola')


.. parsed-literal::

    hola


.. code:: python

    print(a)


.. parsed-literal::

    None


Con esa definición de la función ``caida`` podemos obtener los dos
valores de velocidad y posición simultáneamente

.. code:: python

    t1 = 1
    v1, h1 = caida(t1, 10)

.. code:: python

    print(f"A tiempo {t1:.1f} s, la veloc. es {v1:.2f} m/s y la altura es {h1:.2f} m")


.. parsed-literal::

    A tiempo 1.0 s, la veloc. es 0.20 m/s y la altura es 15.10 m


.. code:: python

    t1 = 1
    v1, h1 = caida(t1, 10)
    print(f"A tiempo {t1:.1f} s, la veloc. es {v1:.2f} m/s y la altura es {h1:.2f} m")

Documentación (doc strings)
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Cuando definimos la función le agregamos un string con una descripción.
Esta puede utilizarse luego como documentación

.. code:: python

    help(caida)


.. parsed-literal::

    Help on function caida in module __main__:
    
    caida(t, v_0)
        Cálculo de velocidad y posición para una partícula en caída libre como función del tiempo
        El tiempo `t` está en segundos
        v_0 es la velocidad inicial
        Devuelve:
        v,h
        donde:
        `v` es la velocidad en m/s
        `h` es la altura en m
    


Las funciones son objetos
~~~~~~~~~~~~~~~~~~~~~~~~~

Las funciones en **Python**, como en la mayoría de los lenguajes, usan
una notación similar a la de las funciones matemáticas, con un nombre y
uno o más argumentos entre paréntesis. Por ejemplo, ya usamos la función
``sum`` cuyo argumento puede ser un array o lista de números

.. code:: python

    print(sum)


.. parsed-literal::

    <built-in function sum>


.. code:: python

    f = sum
    print(f)


.. parsed-literal::

    <built-in function sum>


.. code:: python

    vec = [1.32, 2, -1]

.. code:: python

    print(sum(vec), f(vec))


.. parsed-literal::

    2.3200000000000003 2.3200000000000003


.. code:: python

    a1 = caida(1,10)
    f1 = caida
    print(a1)
    print(caida(1.5, 10))
    print(f1(1.5, 10))


.. parsed-literal::

    (0.1999999999999993, 15.1)
    (-4.700000000000001, 13.975)
    (-4.700000000000001, 13.975)


.. code:: python

    help(f1)


.. parsed-literal::

    Help on function caida in module __main__:
    
    caida(t, v_0)
        Cálculo de velocidad y posición para una partícula en caída libre como función del tiempo
        El tiempo `t` está en segundos
        v_0 es la velocidad inicial
        Devuelve:
        v,h
        donde:
        `v` es la velocidad en m/s
        `h` es la altura en m
    


Ejercicios (e)
--------------

6. Usando estructuras de control, calcule la suma:

   .. math::  s_{1} = \frac{1}{2} \left(\sum_{k=1}^{100}k^{-1} \right)

   1. Incluyendo todos los valores de ``k``
   2. Incluyendo únicamente los valores pares de ``k``.


